{% macro route_initialization_macro() %}
<script>
(function() {
    'use strict';
    
    // Route initialization logic contained in the macro
    document.addEventListener('DOMContentLoaded', function() {
        console.log('Route initialization starting...');
        
        // Ensure currentRoute is defined
        if (typeof window.currentRoute === 'undefined') {
            window.currentRoute = { name: '', duration_seconds: 600, prop: '', tricks: [] };
        }
        
        // Initialize route from query parameter if it exists
        if (window.initialRoute) {
            initializeFromInitialRoute(window.initialRoute);
        }
        
        // Initialize event listeners
        initializeEventListeners();
        
        // Listen for route helpers to be ready, then do initial setup
        document.addEventListener('routeHelpersReady', () => {
            console.log('Route helpers ready event received');
            setupRouteHelpers();
        });
        
        // Fallback: also try after a longer delay in case the event doesn't fire
        setTimeout(() => {
            if (!window.allTricks || window.allTricks.length === 0) {
                console.log('Fallback: trying initial prop setup...');
                setupRouteHelpers();
            }
        }, 1000);
    });
    
    function initializeFromInitialRoute(initialRoute) {
        console.log('Initializing from initial route:', initialRoute);
        
        // Set route name with a small delay to ensure DOM is ready
        setTimeout(() => {
            const routeNameInput = document.getElementById('route_name');
            if (routeNameInput) {
                routeNameInput.value = initialRoute.name || '';
                routeNameInput.dispatchEvent(new Event('input', { bubbles: true }));
            }
        }, 0);

        window.currentRoute.name = initialRoute.name || '';

        // Set duration
        const durationMinutes = Math.floor(initialRoute.duration_seconds / 60);
        const durationSlider = document.getElementById('route-duration-slider');
        const durationValue = document.getElementById('route-duration-value');
        
        if (durationSlider) durationSlider.value = durationMinutes;
        if (durationValue) durationValue.textContent = durationMinutes;
        window.currentRoute.duration_seconds = initialRoute.duration_seconds;

        // Set prop type
        window.currentRoute.prop = initialRoute.prop;
        const propInput = document.querySelector(`input[value="${initialRoute.prop}"]`);
        if (propInput) {
            propInput.checked = true;
            const propOption = propInput.closest('.prop-option');
            if (propOption) {
                propOption.classList.add('selected');
            }
            
            // Initialize prop-specific functionality for the initial route prop
            const propSettings = window.propsSettings && window.propsSettings[initialRoute.prop];
            if (propSettings) {
                // Update relevant tags for this prop
                if (typeof window.updateRelevantTags === 'function') {
                    window.updateRelevantTags(propSettings.relevant_tags, 'available');
                }
                
                // Set max throw for this prop
                if (typeof window.setMaxThrowForProp === 'function') {
                    window.setMaxThrowForProp(propSettings);
                }
                
                // Update custom trick props range for initial route
                if (typeof window.updateCustomTrickPropsRange === 'function') {
                    window.updateCustomTrickPropsRange(propSettings.min_props, propSettings.max_props);
                }
            }
            
            // Fetch tricks for the initial prop type
            if (typeof window.fetchTricks === 'function') {
                window.fetchTricks({ propType: initialRoute.prop })
                    .then(tricks => {
                        window.allTricks = tricks;
                        // Set tricks only after allTricks is loaded
                        window.currentRoute.tricks = initialRoute.tricks || [];
                        if (typeof window.updateSearchTricks === 'function') {
                            window.updateSearchTricks();
                        }
                        if (typeof window.updateRouteDisplay === 'function') {
                            window.updateRouteDisplay();
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching tricks:', error);
                        if (!window.allTricks || window.allTricks.length === 0) {
                            if (typeof window.showToast === 'function') {
                                window.showToast('Error loading tricks. Please try again.');
                            }
                        }
                    });
            } else {
                // Fallback if fetchTricks not available
                window.currentRoute.tricks = initialRoute.tricks || [];
                if (typeof window.updateRouteDisplay === 'function') {
                    window.updateRouteDisplay();
                }
            }
        } else {
            // Set tricks if no prop input found
            window.currentRoute.tricks = initialRoute.tricks || [];
            if (typeof window.updateRouteDisplay === 'function') {
                window.updateRouteDisplay();
            }
        }
    }
    
    function initializeEventListeners() {
        console.log('Initializing event listeners...');
        
        // Route name input
        const routeNameInput = document.getElementById('route_name');
        if (routeNameInput) {
            routeNameInput.addEventListener('input', function(e) {
                window.currentRoute.name = e.target.value;
                if (typeof window.updateRouteDisplay === 'function') {
                    window.updateRouteDisplay();
                }
            });
        }

        // Route duration slider
        const routeDurationSlider = document.getElementById('route-duration-slider');
        const routeDurationValue = document.getElementById('route-duration-value');
        const routeDurationInput = document.getElementById('route-duration-input');
        
        if (routeDurationSlider) {
            routeDurationSlider.addEventListener('input', () => {
                const minutes = parseInt(routeDurationSlider.value);
                if (routeDurationValue) routeDurationValue.textContent = minutes;
                if (routeDurationInput) routeDurationInput.value = minutes;
                window.currentRoute.duration_seconds = minutes * 60;
            });
        }

        // Siteswap-X toggle
        const siteswapToggle = document.getElementById('toggle-siteswap-x-checkbox');
        if (siteswapToggle) {
            siteswapToggle.addEventListener('change', function() {
                if (typeof window.toggleSiteswapXEverywhere === 'function') {
                    window.toggleSiteswapXEverywhere();
                }
            });
        }

        // Available tricks filters
        const maxThrowInput = document.getElementById('max-throw-input');
        if (maxThrowInput) {
            maxThrowInput.addEventListener('input', () => {
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        }

        // Exclude tags for available tricks
        document.querySelectorAll('input[name="exclude_tags_available"]').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Category checkboxes for available tricks
        document.querySelectorAll('.category-checkbox-available').forEach(checkbox => {
            checkbox.addEventListener('change', function(e) {
                e.stopPropagation();
                const category = this.id.replace('category-available-', '');
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox-available[data-category="${category}"]`);
                relatedCheckboxes.forEach(cb => {
                    cb.checked = this.checked;
                });
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Update category checkbox when individual tags change (available tricks)
        document.querySelectorAll('.tag-checkbox-available').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const category = this.dataset.category;
                const categoryCheckbox = document.getElementById(`category-available-${category}`);
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox-available[data-category="${category}"]`);
                const allChecked = Array.from(relatedCheckboxes).every(cb => cb.checked);
                const someChecked = Array.from(relatedCheckboxes).some(cb => cb.checked);
                categoryCheckbox.checked = allChecked;
                categoryCheckbox.indeterminate = someChecked && !allChecked;
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Custom trick functionality
        const addCustomTrickBtn = document.getElementById('add_custom_trick');
        if (addCustomTrickBtn) {
            addCustomTrickBtn.addEventListener('click', function() {
                const name = document.getElementById('custom_trick_name').value.trim();
                const propsCount = parseInt(document.getElementById('custom_trick_props').value);
                const comment = document.getElementById('custom_trick_comment').value.trim();

                if (!name) {
                    if (typeof window.showToast === 'function') {
                        window.showToast('Please enter a trick name', 'custom_trick_name');
                    }
                    return;
                }

                const customTrick = {
                    name: name,
                    props_count: propsCount,
                    difficulty: 30,
                    tags: [],
                    comment: comment || null
                };

                if (typeof window.addTrickToRoute === 'function') {
                    window.addTrickToRoute(customTrick);
                }

                // Clear only the name and comment fields
                document.getElementById('custom_trick_name').value = '';
                document.getElementById('custom_trick_comment').value = '';
            });
        }

        // Custom trick props slider
        const customTrickPropsSlider = document.getElementById('custom_trick_props');
        const customTrickPropsValue = document.getElementById('custom_trick_props_value');
        if (customTrickPropsSlider && customTrickPropsValue) {
            customTrickPropsValue.textContent = parseInt(customTrickPropsSlider.value);
            customTrickPropsSlider.addEventListener('input', () => {
                const value = parseInt(customTrickPropsSlider.value);
                customTrickPropsValue.textContent = value;
            });
        }

        // View route functionality
        const viewRouteBtn = document.getElementById('view_route');
        if (viewRouteBtn) {
            viewRouteBtn.addEventListener('click', handleViewRoute);
        }

        // Tag category functionality
        document.querySelectorAll('.tag-category-title').forEach(title => {
            title.addEventListener('click', function(e) {
                if (e.target.type === 'checkbox') return;
                
                const header = this.closest('.tag-category-header');
                const content = header.nextElementSibling;
                content.classList.toggle('expanded');
            });
        });

        // Category checkbox functionality
        document.querySelectorAll('.category-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function(e) {
                e.stopPropagation();
                
                const category = this.id.replace('category-', '');
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox[data-category="${category}"]`);
                relatedCheckboxes.forEach(cb => {
                    cb.checked = this.checked;
                });
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Update category checkbox when individual tags change
        document.querySelectorAll('.tag-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const category = this.dataset.category;
                const categoryCheckbox = document.getElementById(`category-${category}`);
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox[data-category="${category}"]`);
                const allChecked = Array.from(relatedCheckboxes).every(cb => cb.checked);
                const someChecked = Array.from(relatedCheckboxes).some(cb => cb.checked);
                
                categoryCheckbox.checked = allChecked;
                categoryCheckbox.indeterminate = someChecked && !allChecked;
                
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });
    }
    
    function setupRouteHelpers() {
        console.log('Setting up route helpers...');
        
        // Initialize prop selection if function is available
        if (typeof window.initializePropSelection === 'function') {
            console.log('Calling initializePropSelection');
            window.initializePropSelection();
        } else {
            console.error('initializePropSelection function not available');
        }
        
        setTimeout(() => {
            console.log('Initial prop setup starting...');
            const selectedPropInput = document.querySelector('.prop-option-input:checked');
            console.log('Selected prop input:', selectedPropInput ? selectedPropInput.value : 'none found');
            
            // Force an update of the selected prop to ensure tags and max throw are initialized
            if (typeof window.updatePropSelection === 'function') {
                console.log('Calling updatePropSelection');
                window.updatePropSelection();
            } else {
                console.error('updatePropSelection function not available');
            }
            
            // Ensure tricks are fetched for the selected prop if not already loaded
            if ((!window.allTricks || window.allTricks.length === 0) && selectedPropInput && !window._currentFetchPromise) {
                console.log('No tricks loaded and no fetch in progress, fetching for prop:', selectedPropInput.value);
                if (typeof window.fetchTricks === 'function') {
                    window.fetchTricks({ propType: selectedPropInput.value })
                        .then(tricks => {
                            console.log('Initial fetch SUCCESS:', tricks.length, 'tricks loaded');
                            window.allTricks = tricks;
                            if (typeof window.UpdateAvailableTricks === 'function') {
                                console.log('Calling UpdateAvailableTricks after initial fetch');
                                window.UpdateAvailableTricks();
                            }
                        })
                        .catch(error => {
                            console.error('Initial fetch FAILED:', error);
                        });
                } else {
                    console.error('fetchTricks function not available for initial load');
                }
            }
        }, 100);
    }
    
    async function handleViewRoute() {
        // Pull the typed route name into currentRoute before validating
        const typedName = document.getElementById('route_name') ? document.getElementById('route_name').value.trim() : '';
        if (typedName) {
            window.currentRoute.name = typedName;
        }
        
        // If no name was entered, show a non-blocking toast but allow viewing the route
        if (!window.currentRoute.name) {
            if (typeof window.showToast === 'function') {
                window.showToast('No route name provided. Proceeding to view without a name.');
            }
        }
        
        if (!window.currentRoute.prop) {
            if (typeof window.showToast === 'function') {
                window.showToast('Please select a prop type before viewing.', 'prop-slider');
            }
            return;
        }

        try {
            // Build a complete payload for serialization
            const durationMinutes = document.getElementById('route-duration-input') ? parseInt(document.getElementById('route-duration-input').value) : 10;
            const payload = {
                name: window.currentRoute.name,
                prop: window.currentRoute.prop,
                duration_seconds: Number.isFinite(durationMinutes) ? durationMinutes * 60 : 600,
                tricks: Array.isArray(window.currentRoute.tricks) ? window.currentRoute.tricks.map(t => ({
                    name: t.name,
                    props_count: t.props_count,
                    difficulty: t.difficulty,
                    tags: t.tags || [],
                    comment: t.comment || null
                })) : []
            };

            // Serialize the route
            const response = await fetch('/api/serialize_route', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload)
            });
            const serialized = await response.text();
            
            // Redirect to the created_route page with the serialized route
            const encodedRoute = encodeURIComponent(serialized);
            window.location.href = `/created_route?route=${encodedRoute}`;
        } catch (error) {
            console.error('Error preparing route for viewing:', error);
            if (typeof window.showToast === 'function') {
                window.showToast('Error preparing route for viewing. Please try again.');
            }
        }
    }
    
    // Export main delegation function
    window.updateSearchTricks = function() {
        if (typeof window.UpdateAvailableTricks === 'function') {
            window.UpdateAvailableTricks();
        } else {
            console.error('UpdateAvailableTricks function not available from macro');
        }
    };
    
    console.log('Route initialization macro loaded');
})();
</script>
{% endmacro %}