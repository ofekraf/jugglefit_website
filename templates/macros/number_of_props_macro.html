{% macro number_of_props_macro(id_prefix='props', mode='range') %}
<div class="form-section">
    <label class="form-label">Number of Props</label>
    <div class="slider-container">
        <div id="{{ id_prefix }}-slider" class="custom-slider"></div>
        <div class="slider-values">
            <span id="{{ id_prefix }}-range"></span>
        </div>
        {% if mode == 'range' %}
        <input type="hidden" id="min-{{ id_prefix }}-input" name="min_{{ id_prefix }}">
        <input type="hidden" id="max-{{ id_prefix }}-input" name="max_{{ id_prefix }}">
        {% else %}
        <input type="hidden" id="{{ id_prefix }}-input" name="{{ id_prefix }}">
        {% endif %}
    </div>
</div>

<script>
// Initialize props slider using global propsSettings (defined in page)
document.addEventListener('DOMContentLoaded', function() {
    try {
        const propsSlider = document.getElementById('{{ id_prefix }}-slider');
        const propsRange = document.getElementById('{{ id_prefix }}-range');
        {% if mode == 'range' %}
        const propsMinInput = document.getElementById('min-{{ id_prefix }}-input');
        const propsMaxInput = document.getElementById('max-{{ id_prefix }}-input');
        {% else %}
        const propsInput = document.getElementById('{{ id_prefix }}-input');
        {% endif %}
        
        if (!propsSlider || typeof noUiSlider === 'undefined') return;

        const checkedPropInput = document.querySelector('.prop-option-input:checked');
        const selectedProp = checkedPropInput ? checkedPropInput.value : Object.keys(window.propsSettings || {})[0];
        const propSettings = (window.propsSettings || {})[selectedProp] || {min_props:2, max_props:9};
        const minProps = propSettings.min_props;
        const maxProps = propSettings.max_props;
        
        const mode = '{{ mode }}';

        if (!propsSlider.noUiSlider) {
            noUiSlider.create(propsSlider, {
                start: mode === 'range' ? [minProps, maxProps] : [minProps],
                connect: true,
                range: { 'min': minProps, 'max': maxProps },
                step: 1,
                format: {
                    to: (value) => Math.round(value),
                    from: (value) => parseFloat(value)
                }
            });

            propsSlider.noUiSlider.on('update', function(values) {
                if (mode === 'range') {
                    propsRange.textContent = `Min: ${values[0]}, Max: ${values[1]}`;
                    propsMinInput.value = Math.round(values[0]);
                    propsMaxInput.value = Math.round(values[1]);
                } else {
                    propsRange.textContent = `${values[0]}`;
                    propsInput.value = Math.round(values[0]);
                }
                
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        }
    } catch (e) {
        console.error('Error initializing props slider', e);
    }
});

// Expose a helper to update the props slider range and values from other scripts
window.updatePropsSliderRange = window.updatePropsSliderRange || function(minProps, maxProps, idPrefix) {
    idPrefix = idPrefix || 'props';
    try {
        const propsSlider = document.getElementById(idPrefix + '-slider');
        const propsRange = document.getElementById(idPrefix + '-range');
        const propsMinInput = document.getElementById('min-' + idPrefix + '-input');
        const propsMaxInput = document.getElementById('max-' + idPrefix + '-input');
        const propsInput = document.getElementById(idPrefix + '-input');
        
        if (!propsSlider) return;
        
        // Determine mode based on inputs existence
        const isRange = !!propsMinInput;
        
        // If slider already exists, update options; otherwise create it
        if (propsSlider.noUiSlider) {
            const currentStart = isRange ? [minProps, maxProps] : [minProps];
            propsSlider.noUiSlider.updateOptions({
                range: { 'min': minProps, 'max': maxProps },
                start: currentStart
            });
            // Manually set values in case updateOptions doesn't trigger update event immediately
            if (propsRange) {
                propsRange.textContent = isRange ? `Min: ${minProps}, Max: ${maxProps}` : `${minProps}`;
            }
            if (isRange) {
                if (propsMinInput) propsMinInput.value = minProps;
                if (propsMaxInput) propsMaxInput.value = maxProps;
            } else {
                if (propsInput) propsInput.value = minProps;
            }
        } else if (typeof noUiSlider !== 'undefined') {
            noUiSlider.create(propsSlider, {
                start: isRange ? [minProps, maxProps] : [minProps],
                connect: true,
                range: { 'min': minProps, 'max': maxProps },
                step: 1,
                format: {
                    to: (value) => Math.round(value),
                    from: (value) => parseFloat(value)
                }
            });
            propsSlider.noUiSlider.on('update', function(values) {
                if (isRange) {
                    if (propsRange) propsRange.textContent = `Min: ${values[0]}, Max: ${values[1]}`;
                    if (propsMinInput) propsMinInput.value = Math.round(values[0]);
                    if (propsMaxInput) propsMaxInput.value = Math.round(values[1]);
                } else {
                    if (propsRange) propsRange.textContent = `${values[0]}`;
                    if (propsInput) propsInput.value = Math.round(values[0]);
                }
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        }
    } catch (e) {
        console.error('Error in updatePropsSliderRange', e);
    }
};
</script>

{% endmacro %}
