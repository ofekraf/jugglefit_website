{% extends "macros/base.html" %}

{% block head %}
<script>
// Trick filtering constants from Flask context
const MIN_TRICK_PROPS_COUNT = {{ MIN_TRICK_PROPS_COUNT }};
const MAX_TRICK_PROPS_COUNT = {{ MAX_TRICK_PROPS_COUNT }};
const MIN_TRICK_DIFFICULTY = {{ MIN_TRICK_DIFFICULTY }};
const MAX_TRICK_DIFFICULTY = {{ MAX_TRICK_DIFFICULTY }};
</script>
<script>
// Make props settings available globally for macros
const propsSettings = {{ props_settings|tojson|safe }};
window.propsSettings = propsSettings;
</script>
<script>
// Initialize window.currentRoute properly
window.currentRoute = { name: '', duration_seconds: 600, prop: '', tricks: [] };
</script>
<script>
// Expose initial_route from Flask as window.initialRoute for JS
window.initialRoute = {{ initial_route|tojson|safe }};

// Initialize currentRoute from initial_route if available
if (window.initialRoute && window.initialRoute.tricks) {
    window.currentRoute = {
        name: window.initialRoute.name || '',
        duration_seconds: window.initialRoute.duration_seconds || 600,
        prop: window.initialRoute.prop || '',
        tricks: window.initialRoute.tricks || []
    };
}
</script>
{% endblock %}

{% block title %}Create Your Own Route{% endblock %}
{% block content %}
<div class="route-page">
    <div class="route-header">
        <h1 class="route-title">Build Your Route</h1>
        <div class="route-description">
            <p>Create a custom route by selecting tricks.</p>
        </div>
        <div class="siteswap-x-toggle-row center-row">
            <label class="siteswap-x-toggle-label">
                <input type="checkbox" id="toggle-siteswap-x-checkbox" class="siteswap-x-toggle-checkbox"> Siteswap-X
            </label>
        </div>
    </div>

    {% from 'macros/route_name_input.html' import route_name_input %}
    {% from 'macros/prop_selection_macro.html' import prop_selection_macro %}
    {% from 'macros/number_of_props_macro.html' import number_of_props_macro %}
    {% from 'macros/difficulty_range_macro.html' import difficulty_range_macro %}
    {% from 'macros/route_duration_macro.html' import route_duration_macro %}
    {% from 'macros/limit_max_throw_macro.html' import limit_max_throw_macro %}
    {% from 'macros/relevant_tags_macro.html' import relevant_tags_macro %}
    {% from 'macros/available_tricks_macro.html' import available_tricks_macro %}

    <div class="route-form">
        {{ route_name_input() }}
        {{ route_duration_macro() }}

        {{ prop_selection_macro(props_settings, main_props, initial_route.prop if initial_route else None) }}

        <!-- Route Display -->
        <div class="form-section">
            <div class="route-container">
                <div class="route-content">
                    {% if initial_route %}
                        {% set route = initial_route %}
                        {% include "macros/route_display.html" %}
                    {% else %}
                        <div id="route-sections" class="route-sections"></div>
                    {% endif %}
                </div>
            </div>
            <div class="route-actions">
                <div class="route-buttons">
                    <button type="button" id="view_route" class="primary-button">View Route</button>
                </div>
            </div>
        </div>

        <!-- Add Custom Trick Section -->
        <div class="form-section custom-trick-section">
            <h4 class="subsection-title">Add Custom Trick</h4>
            <div class="custom-trick-form">
                <div class="form-row">
                    <div class="form-group">
                        <label for="custom_trick_name">Trick Name</label>
                        <input type="text" id="custom_trick_name" class="form-input" placeholder="Enter trick name">
                    </div>
                    <div class="form-group">
                        <label for="custom_trick_siteswap">Siteswap-X</label>
                        <input type="text" id="custom_trick_siteswap" class="form-input" placeholder="Enter siteswap-x notation">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="custom_trick_props">Number of Props</label>
                        <div class="slider-container">
                            <div class="slider-wrapper">
                                <input type="range" id="custom_trick_props" class="custom-range" min="1" max="{{ MAX_TRICK_PROPS_COUNT }}" value="3">
                                <span id="custom_trick_props_value" class="slider-value">3</span>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="custom_trick_comment">Comment (Optional)</label>
                        <textarea id="custom_trick_comment" class="form-input" placeholder="Add a comment about the trick"></textarea>
                    </div>
                </div>
                <button type="button" id="add_custom_trick" class="add-trick">Add</button>
            </div>
        </div>

        <div class="form-section">
            <div class="route-form">
                <h4 class="subsection-title">Add Tricks</h4>
                <label class="form-label">Available Tricks</label>

                {{ number_of_props_macro() }}
                {{ difficulty_range_macro() }}
                {{ limit_max_throw_macro(props_settings) }}
                {{ relevant_tags_macro(tag_category_map, 'available') }}
                {{ available_tricks_macro() }}
            </div>
        </div>
    </div>
</div>

<!-- Toast Notification -->
<div id="toast" class="toast-notification"></div>

<!-- Include noUISlider CSS and JS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<script src="{{ url_for('static', filename='js/general.js') }}"></script>
<script src="{{ url_for('static', filename='js/siteswap_x.js') }}"></script>

<script type="module">
    console.log('Module script starting...');
    try {
        const { fetchTricks, updatePropsSliderRange, updateRelevantTags, setMaxThrowForProp, initMaxThrowBindings, initializePropSelection, refreshFromRoute, updateRouteDisplay, addTrickToRoute, removeTrick, updateCustomTrickPropsRange } = await import("{{ url_for('static', filename='js/route_helpers.js') }}");
        console.log('Route helpers imported successfully');
        
        // Make functions available globally for non-module scripts and macros
        window.fetchTricks = fetchTricks;
        window.updateRelevantTags = updateRelevantTags;
        window.setMaxThrowForProp = setMaxThrowForProp;
        window.updatePropsSliderRange = updatePropsSliderRange;
        window.initializePropSelection = initializePropSelection;
        window.refreshFromRoute = refreshFromRoute;
        window.updateRouteDisplay = updateRouteDisplay;
        window.addTrickToRoute = addTrickToRoute;
        window.removeTrick = removeTrick;
        window.updateCustomTrickPropsRange = updateCustomTrickPropsRange;
        console.log('Functions exposed to window');
        
        // Initialize max throw bindings
        initMaxThrowBindings();
        console.log('Max throw bindings initialized');
        
        // Trigger initial prop setup after functions are available
        setTimeout(() => {
            console.log('Triggering initial prop setup from module...');
            console.log('Available functions:', {
                fetchTricks: typeof window.fetchTricks,
                UpdateAvailableTricks: typeof window.UpdateAvailableTricks,
                initializePropSelection: typeof window.initializePropSelection,
                refreshFromRoute: typeof window.refreshFromRoute
            });
            console.log('Current allTricks:', window.allTricks ? window.allTricks.length : 'undefined');
            console.log('Current route:', window.currentRoute);
            
            // Check for siteswap-x URL parameter and set checkbox
            const urlParams = new URLSearchParams(window.location.search);
            const siteswapXParam = urlParams.get('siteswapx');
            if (siteswapXParam === '1') {
                const siteswapToggle = document.getElementById('toggle-siteswap-x-checkbox');
                if (siteswapToggle) {
                    siteswapToggle.checked = true;
                }
            }
            
            // Refresh GUI from currentRoute (which now contains initial route data)
            if (typeof window.refreshFromRoute === 'function') {
                console.log('Calling refreshFromRoute to initialize GUI...');
                window.refreshFromRoute();
            }
            
            // Directly call initializePropSelection if functions are available
            if (typeof window.initializePropSelection === 'function') {
                console.log('Calling initializePropSelection directly from module setup...');
                window.initializePropSelection();
            }
            
            const event = new CustomEvent('routeHelpersReady');
            document.dispatchEvent(event);
        }, 100);
        
    } catch (error) {
        console.error('Failed to import route helpers:', error);
    }
</script>

<!-- Main page functionality script -->
<script>
function setupPageFunctionality() {
    console.log('Setting up page functionality...');


}

// Route initialization functions
</script>

<!-- Inlined route initialization logic (previously in macros/route_initialization_macro.html) -->
<script>
(function() {
    'use strict';
    
    // Removed all initialization logic to prevent post-load interference with comment positioning
    
    function initializeFromInitialRoute(initialRoute) {
        console.log('Initializing from initial route:', initialRoute);
        
        // Set route name with a small delay to ensure DOM is ready
        setTimeout(() => {
            const routeNameInput = document.getElementById('route_name');
            if (routeNameInput) {
                routeNameInput.value = initialRoute.name || '';
                routeNameInput.dispatchEvent(new Event('input', { bubbles: true }));
            }
        }, 0);

        window.currentRoute.name = initialRoute.name || '';

        // Set duration
        const durationMinutes = Math.floor(initialRoute.duration_seconds / 60);
        const durationSlider = document.getElementById('route-duration-slider');
        const durationValue = document.getElementById('route-duration-value');
        
        if (durationSlider) durationSlider.value = durationMinutes;
        if (durationValue) durationValue.textContent = durationMinutes;
        window.currentRoute.duration_seconds = initialRoute.duration_seconds;

        // Set prop type
        window.currentRoute.prop = initialRoute.prop;
        console.log('Initial route prop set to:', initialRoute.prop);
        const propInput = document.querySelector(`input[value="${initialRoute.prop}"]`);
        if (propInput) {
            propInput.checked = true;
            const propOption = propInput.closest('.prop-option');
            if (propOption) {
                propOption.classList.add('selected');
            }
            
            // Set tricks from initial route
            window.currentRoute.tricks = initialRoute.tricks || [];
            
            // Initialize prop-specific functionality for the initial route prop
            const propSettings = window.propsSettings && window.propsSettings[initialRoute.prop];
            if (propSettings) {
                // Update relevant tags for this prop
                if (typeof window.updateRelevantTags === 'function') {
                    window.updateRelevantTags(propSettings.relevant_tags, 'available');
                }
                
                // Set max throw for this prop
                if (typeof window.setMaxThrowForProp === 'function') {
                    window.setMaxThrowForProp(propSettings);
                }
                
                // Update custom trick props range for initial route
                if (typeof window.updateCustomTrickPropsRange === 'function') {
                    window.updateCustomTrickPropsRange(propSettings.min_props, propSettings.max_props);
                }
            }
            
            // Update route display after setting tricks
            if (typeof window.updateRouteDisplay === 'function') {
                window.updateRouteDisplay();
            }
        } else {
            // Set tricks if no prop input found
            window.currentRoute.tricks = initialRoute.tricks || [];
            if (typeof window.updateRouteDisplay === 'function') {
                window.updateRouteDisplay();
            }
        }
    }
    
    function initializeEventListeners() {
        console.log('Initializing event listeners...');
        
        // Route name input - simple: change currentRoute and refresh
        const routeNameInput = document.getElementById('route_name');
        if (routeNameInput) {
            routeNameInput.addEventListener('input', function(e) {
                if (window.currentRoute) {
                    window.currentRoute.name = e.target.value;
                    // Only refresh route display, not all GUI (avoid cursor jumping)
                    if (typeof window.updateRouteDisplay === 'function') {
                        window.updateRouteDisplay();
                    }
                }
            });
        }

        // Route duration slider - simple: change currentRoute and refresh
        const routeDurationSlider = document.getElementById('route-duration-slider');
        
        if (routeDurationSlider) {
            routeDurationSlider.addEventListener('input', () => {
                const minutes = parseInt(routeDurationSlider.value);
                if (window.currentRoute) {
                    window.currentRoute.duration_seconds = minutes * 60;
                    if (typeof window.refreshFromRoute === 'function') {
                        window.refreshFromRoute();
                    }
                }
            });
        }

        // Siteswap-X toggle
        const siteswapToggle = document.getElementById('toggle-siteswap-x-checkbox');
        if (siteswapToggle) {
            siteswapToggle.addEventListener('change', function() {
                if (typeof window.toggleSiteswapXEverywhere === 'function') {
                    window.toggleSiteswapXEverywhere();
                }
            });
        }

        // Available tricks filters
        const maxThrowInput = document.getElementById('max-throw-input');
        if (maxThrowInput) {
            maxThrowInput.addEventListener('input', () => {
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        }

        // Prop selection radio buttons - initialize tricks and tags when prop is selected
        document.querySelectorAll('input[name="prop"]').forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked && typeof window.initializePropSelection === 'function') {
                    console.log('Prop changed to:', this.value, '- initializing tricks and tags');
                    window.initializePropSelection();
                }
            });
        });

        // Wait for route helpers to be ready before initializing
        function initializeWhenReady() {
            const currentlySelectedProp = document.querySelector('input[name="prop"]:checked');
            if (currentlySelectedProp && typeof window.initializePropSelection === 'function') {
                console.log('Initializing tricks and tags for currently selected prop:', currentlySelectedProp.value);
                console.log('Available functions at initialization:', {
                    initializePropSelection: typeof window.initializePropSelection,
                    fetchTricks: typeof window.fetchTricks,
                    UpdateAvailableTricks: typeof window.UpdateAvailableTricks,
                    updateRelevantTags: typeof window.updateRelevantTags
                });
                window.initializePropSelection();
            } else if (currentlySelectedProp) {
                console.log('Prop selected but initializePropSelection not available yet, waiting...');
                setTimeout(initializeWhenReady, 100);
            }
        }

        // Listen for route helpers ready event
        document.addEventListener('routeHelpersReady', initializeWhenReady);
        
        // Also try immediate initialization in case the event already fired
        setTimeout(initializeWhenReady, 50);

        // Debug function accessible from console
        window.debugInitialization = function() {
            console.log('=== DEBUG INITIALIZATION ===');
            const selectedProp = document.querySelector('input[name="prop"]:checked');
            console.log('Selected prop:', selectedProp ? selectedProp.value : 'none');
            console.log('Function availability:', {
                fetchTricks: typeof window.fetchTricks,
                initializePropSelection: typeof window.initializePropSelection,
                UpdateAvailableTricks: typeof window.UpdateAvailableTricks,
                updateRelevantTags: typeof window.updateRelevantTags
            });
            console.log('allTricks:', window.allTricks ? window.allTricks.length : 'undefined');
            console.log('propsSettings:', window.propsSettings);
            
            if (selectedProp && typeof window.initializePropSelection === 'function') {
                console.log('Calling initializePropSelection manually...');
                window.initializePropSelection();
            }
        };
        
        // Manual trigger function
        window.manualInit = function() {
            console.log('Manual initialization triggered');
            initializeWhenReady();
        };

        // Exclude tags for available tricks
        document.querySelectorAll('input[name="exclude_tags_available"]').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Category checkboxes for available tricks
        document.querySelectorAll('.category-checkbox-available').forEach(checkbox => {
            checkbox.addEventListener('change', function(e) {
                e.stopPropagation();
                const category = this.id.replace('category-available-', '');
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox-available[data-category="${category}"]`);
                relatedCheckboxes.forEach(cb => {
                    cb.checked = this.checked;
                });
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Update category checkbox when individual tags change (available tricks)
        document.querySelectorAll('.tag-checkbox-available').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const category = this.dataset.category;
                const categoryCheckbox = document.getElementById(`category-available-${category}`);
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox-available[data-category="${category}"]`);
                const allChecked = Array.from(relatedCheckboxes).every(cb => cb.checked);
                const someChecked = Array.from(relatedCheckboxes).some(cb => cb.checked);
                if (categoryCheckbox) {
                    categoryCheckbox.checked = allChecked;
                    categoryCheckbox.indeterminate = someChecked && !allChecked;
                }
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Custom trick functionality
        const addCustomTrickBtn = document.getElementById('add_custom_trick');
        console.log('Add custom trick button found:', !!addCustomTrickBtn);
        if (addCustomTrickBtn) {
            addCustomTrickBtn.addEventListener('click', function() {
                console.log('Add custom trick button clicked');
                const name = document.getElementById('custom_trick_name').value.trim();
                const siteswapX = document.getElementById('custom_trick_siteswap').value.trim();
                const propsCount = parseInt(document.getElementById('custom_trick_props').value);
                const comment = document.getElementById('custom_trick_comment').value.trim();

                console.log('Custom trick values:', { name, siteswapX, propsCount, comment });

                // Validation: must have at least name or siteswap-x
                if (!name && !siteswapX) {
                    console.log('Validation failed: no name or siteswap-x');
                    if (typeof window.showToast === 'function') {
                        window.showToast('Please enter either a trick name or siteswap-x notation', 'custom_trick_name');
                    }
                    return;
                }

                const customTrick = {
                    name: name || 'Custom Trick',
                    siteswap_x: siteswapX || null,
                    props_count: propsCount,
                    difficulty: 30,
                    tags: [],
                    comment: comment || null
                };

                console.log('Custom trick object:', customTrick);
                console.log('addTrickToRoute function available:', typeof window.addTrickToRoute);

                if (typeof window.addTrickToRoute === 'function') {
                    console.log('Calling addTrickToRoute...');
                    window.addTrickToRoute(customTrick);
                } else {
                    console.error('addTrickToRoute function not available - using direct method');
                    // Fallback to direct addition
                    if (!window.currentRoute) {
                        window.currentRoute = { name: '', duration_seconds: 600, prop: '', tricks: [] };
                    }
                    window.currentRoute.tricks.push(customTrick);
                    if (typeof window.refreshFromRoute === 'function') {
                        window.refreshFromRoute();
                    }
                }

                // Clear the input fields
                document.getElementById('custom_trick_name').value = '';
                document.getElementById('custom_trick_siteswap').value = '';
                document.getElementById('custom_trick_comment').value = '';
            });
        }

        // Custom trick props slider
        const customTrickPropsSlider = document.getElementById('custom_trick_props');
        const customTrickPropsValue = document.getElementById('custom_trick_props_value');
        console.log('Props slider elements found:', { slider: !!customTrickPropsSlider, value: !!customTrickPropsValue });
        if (customTrickPropsSlider && customTrickPropsValue) {
            customTrickPropsValue.textContent = parseInt(customTrickPropsSlider.value);
            customTrickPropsSlider.addEventListener('input', () => {
                const value = parseInt(customTrickPropsSlider.value);
                console.log('Props slider changed to:', value);
                customTrickPropsValue.textContent = value;
            });
        }

        // View route functionality
        const viewRouteBtn = document.getElementById('view_route');
        if (viewRouteBtn) {
            viewRouteBtn.addEventListener('click', handleViewRoute);
        }

        // Tag category functionality
        document.querySelectorAll('.tag-category-title').forEach(title => {
            title.addEventListener('click', function(e) {
                if (e.target.type === 'checkbox') return;
                
                const header = this.closest('.tag-category-header');
                const content = header ? header.nextElementSibling : null;
                if (content) content.classList.toggle('expanded');
            });
        });

        // Category checkbox functionality
        document.querySelectorAll('.category-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function(e) {
                e.stopPropagation();
                
                const category = this.id.replace('category-', '');
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox[data-category="${category}"]`);
                relatedCheckboxes.forEach(cb => {
                    cb.checked = this.checked;
                });
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Update category checkbox when individual tags change
        document.querySelectorAll('.tag-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const category = this.dataset.category;
                const categoryCheckbox = document.getElementById(`category-${category}`);
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox[data-category="${category}"]`);
                const allChecked = Array.from(relatedCheckboxes).every(cb => cb.checked);
                const someChecked = Array.from(relatedCheckboxes).some(cb => cb.checked);
                if (categoryCheckbox) {
                    categoryCheckbox.checked = allChecked;
                    categoryCheckbox.indeterminate = someChecked && !allChecked;
                }
                
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });
    }
    
    function setupRouteHelpers() {
        console.log('Setting up route helpers...');
        
        // Initialize prop selection if function is available
        if (typeof window.initializePropSelection === 'function') {
            console.log('Calling initializePropSelection');
            window.initializePropSelection();
        } else {
            console.error('initializePropSelection function not available');
        }
        
        setTimeout(() => {
            console.log('Initial prop setup starting...');
            const selectedPropInput = document.querySelector('.prop-option-input:checked');
            console.log('Selected prop input:', selectedPropInput ? selectedPropInput.value : 'none found');
            console.log('All prop inputs:', document.querySelectorAll('.prop-option-input').length);
            console.log('Available props:', Array.from(document.querySelectorAll('.prop-option-input')).map(i => i.value));
            
            // Force an update of the selected prop to ensure tags and max throw are initialized
            if (typeof window.updatePropSelection === 'function') {
                console.log('Calling updatePropSelection');
                window.updatePropSelection();
            } else {
                console.error('updatePropSelection function not available');
            }
            
            // Ensure tricks are fetched for the selected prop if not already loaded
            setTimeout(() => {
                if ((!window.allTricks || window.allTricks.length === 0) && selectedPropInput) {
                    console.log('Fallback: fetching tricks for initial prop:', selectedPropInput.value);
                    if (typeof window.fetchTricks === 'function') {
                        // Use the shared fetch which prevents concurrent duplicates
                        window.fetchTricks({ propType: selectedPropInput.value })
                            .then(tricks => {
                                console.log('Fallback fetch SUCCESS:', tricks.length, 'tricks');
                                window.allTricks = tricks;
                                if (typeof window.UpdateAvailableTricks === 'function') {
                                    window.UpdateAvailableTricks();
                                }
                            })
                            .catch(err => console.error('Fallback fetch failed', err));
                    } else {
                        console.error('fetchTricks function not available for fallback fetch');
                    }
                }
            }, 100);
        }, 100);
    }
    
    async function handleViewRoute() {
        // Pull the typed route name into currentRoute before validating
        const typedName = document.getElementById('route_name') ? document.getElementById('route_name').value.trim() : '';
        if (typedName) {
            window.currentRoute.name = typedName;
        }
        
        // If no name was entered, show a non-blocking toast but allow viewing the route
        if (!window.currentRoute.name) {
            if (typeof window.showToast === 'function') {
                window.showToast('No route name provided. Proceeding to view without a name.');
            }
        }
        
        if (!window.currentRoute.prop) {
            if (typeof window.showToast === 'function') {
                window.showToast('Please select a prop type before viewing.', 'prop-slider');
            }
            return;
        }

        try {
            // Build a complete payload for serialization
            const durationSeconds = window.currentRoute.duration_seconds || 600;
            
            // Get tricks from currentRoute
            const allTricks = Array.isArray(window.currentRoute.tricks) ? window.currentRoute.tricks : [];
            
            const payload = {
                name: window.currentRoute.name,
                prop: window.currentRoute.prop,
                duration_seconds: durationSeconds,
                tricks: allTricks.map(t => ({
                    name: t.name,
                    siteswap_x: t.siteswap_x || null,
                    props_count: t.props_count,
                    difficulty: t.difficulty,
                    tags: t.tags || [],
                    comment: t.comment || null
                }))
            };

            // Serialize the route
            console.log('Sending payload to serialize_route:', payload);
            const response = await fetch('/api/serialize_route', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const serialized = await response.text();
            console.log('Received serialized route:', serialized.substring(0, 100) + '...');
            
            // Check if siteswap-x is enabled and add URL param
            const siteswapToggle = document.getElementById('toggle-siteswap-x-checkbox');
            const siteswapXEnabled = siteswapToggle && siteswapToggle.checked;
            
            // Redirect to the created_route page with the serialized route
            const encodedRoute = encodeURIComponent(serialized);
            const url = siteswapXEnabled 
                ? `/created_route?route=${encodedRoute}&siteswapx=1`
                : `/created_route?route=${encodedRoute}`;
            
            console.log('Redirecting to:', url);
            window.location.href = url;
        } catch (error) {
            console.error('Error preparing route for viewing:', error);
            if (typeof window.showToast === 'function') {
                window.showToast('Error preparing route for viewing. Please try again.');
            }
        }
    }
    
    // Export main delegation function
    window.updateSearchTricks = function() {
        console.log('updateSearchTricks called, checking for UpdateAvailableTricks...');
        console.log('Available functions:', {
            UpdateAvailableTricks: typeof window.UpdateAvailableTricks,
            allTricks: window.allTricks ? window.allTricks.length : 'undefined'
        });
        if (typeof window.UpdateAvailableTricks === 'function') {
            console.log('Calling UpdateAvailableTricks...');
            window.UpdateAvailableTricks();
        } else {
            console.error('UpdateAvailableTricks function not available from macro');
        }
    };
    
    console.log('Route initialization inlined');
})();

    console.log('Page functionality setup complete');
}

// Simple approach - wait for everything to be ready
setTimeout(function() {
    console.log('Setting up page functionality with timeout...');
    setupPageFunctionality();
}, 1000);
</script>

<!-- Backup direct implementation for testing -->
<script>
setTimeout(function() {
    // Direct props slider setup
    const slider = document.getElementById('custom_trick_props');
    const valueDisplay = document.getElementById('custom_trick_props_value');
    if (slider && valueDisplay) {
        slider.addEventListener('input', function() {
            valueDisplay.textContent = this.value;
        });
    }
    
    // Simple trick addition - add to currentRoute and refresh
    function addTrickDirectly() {
        const nameInput = document.getElementById('custom_trick_name');
        const siteswapInput = document.getElementById('custom_trick_siteswap');
        const propsInput = document.getElementById('custom_trick_props');
        const commentInput = document.getElementById('custom_trick_comment');
        
        if (!nameInput || !siteswapInput || !propsInput) return;
        
        const name = nameInput.value.trim();
        const siteswap = siteswapInput.value.trim();
        const propsCount = parseInt(propsInput.value) || 3;
        const comment = commentInput ? commentInput.value.trim() : '';
        
        if (!name && !siteswap) {
            alert('Please enter either a trick name or siteswap-x notation');
            return;
        }
        
        // Create trick object
        const trick = {
            name: name || null,
            siteswap_x: siteswap || null,
            props_count: propsCount,
            difficulty: 30,
            tags: [],
            comment: comment || null
        };
        
        // Ensure currentRoute exists
        if (!window.currentRoute) {
            window.currentRoute = { name: '', duration_seconds: 600, prop: '', tricks: [] };
        }
        
        // Add to currentRoute.tricks and refresh
        window.currentRoute.tricks.push(trick);
        if (typeof window.refreshFromRoute === 'function') {
            window.refreshFromRoute();
        }
        
        // Clear form
        nameInput.value = '';
        siteswapInput.value = '';
        if (commentInput) commentInput.value = '';
    }
    
    // Direct add button setup
    const addBtn = document.getElementById('add_custom_trick');
    if (addBtn) {
        addBtn.addEventListener('click', addTrickDirectly);
    }
}, 2000);
</script>
</div>
{% endblock %}
