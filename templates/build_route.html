{% extends "utils/base.html" %}
{% block title %}Create Your Own Route{% endblock %}
{% block content %}
<div class="route-page">
    <div class="route-header">
        <h1 class="route-title">Build Your Route</h1>
        <div class="route-description">
            <p>Create a custom route by selecting tricks and organizing them by prop count.</p>
        </div>
    </div>

    <div class="route-form">
        <div class="form-section">
            <label for="route_name" class="form-label">Route Name</label>
            <input type="text" id="route_name" name="route_name" placeholder="My awesome route" class="form-input" required>
        </div>

        <div class="form-section">
            <label for="route_duration" class="form-label">Route Duration (minutes)</label>
            <input type="number" id="route_duration" name="route_duration" min="1" max="30" value="10" class="form-input" required>
        </div>

        <div class="form-section">
            <label class="form-label">Select Prop</label>
            <div class="prop-group">
                {% for prop in prop_options %}
                    <label class="prop-option {% if loop.first %}selected{% endif %}" data-prop-type="{{ prop }}">
                        <input type="radio" name="prop" class="prop-option-input" value="{{ prop }}" {% if loop.first %}checked{% endif %}> 
                        <span class="prop-option-name">{{ prop }}</span>
                        <div class="prop-icon"></div>
                    </label>
                {% endfor %}
            </div>
        </div>

        <!-- Route Display -->
        <div class="form-section">
            <label class="form-label">Your Route</label>
            <div class="route-container">
                <div class="route-content">
                    <div class="route-sections" id="route-sections">
                        <!-- Route sections will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            <div class="route-actions">
                <button type="button" id="export_route" class="primary-button">Copy Route URL</button>
                <button type="button" id="view_route" class="primary-button">View Route</button>
            </div>
        </div>

        <!-- Add Custom Trick Section -->
        <div class="form-section">
            <label class="form-label">Add Custom Trick</label>
            <div class="custom-trick-form">
                <div class="form-row">
                    <div class="form-group">
                        <label for="custom_trick_name">Trick Name</label>
                        <input type="text" id="custom_trick_name" class="form-input" placeholder="Enter trick name">
                    </div>
                    <div class="form-group">
                        <label for="custom_trick_props">Props Count</label>
                        <input type="number" id="custom_trick_props" class="form-input" min="1" max="9" value="3">
                    </div>
                </div>
                <div class="form-group">
                    <label for="custom_trick_comment">Comment (Optional)</label>
                    <textarea id="custom_trick_comment" class="form-input" placeholder="Add a comment about the trick"></textarea>
                </div>
                <button type="button" id="add_custom_trick" class="add-custom-trick-button">Add Trick</button>
            </div>
        </div>

        <!-- Search and Filter Section -->
        <div class="form-section">
            <label class="form-label">Search Tricks</label>
            <div class="search-container">
                <input type="text" id="search" placeholder="Search tricks..." class="search-input">
            </div>

            <div class="form-section">
                <label class="form-label">Props Count</label>
                <div class="slider-container">
                    <div id="props-slider" class="custom-slider"></div>
                    <div class="slider-values">
                        <span id="props-range">Min: 3, Max: 9</span>
                    </div>
                    <input type="hidden" id="min-props-input" name="min_props" value="3">
                    <input type="hidden" id="max-props-input" name="max_props" value="9">
                </div>
            </div>

            <div class="form-section">
                <label class="form-label">Difficulty Range</label>
                <div class="slider-container">
                    <div id="difficulty-slider" class="custom-slider"></div>
                    <div class="slider-values">
                        <span id="difficulty-range">Min: 20, Max: 30</span>
                    </div>
                    <input type="hidden" id="min-difficulty-input" name="min_difficulty" value="20">
                    <input type="hidden" id="max-difficulty-input" name="max_difficulty" value="30">
                </div>
            </div>

            <div class="form-section">
                <label class="form-label">Exclude Tags</label>
                <div class="tricks-container">
                    <div class="tricks-column">
                        <div id="exclude_tags" class="tags-grid">
                            {% for tag in tag_options %}
                                <div class="checkbox-container">
                                    <input type="checkbox" id="tag-{{ tag }}" name="exclude_tags" value="{{ tag }}">
                                    <label for="tag-{{ tag }}">{{ tag }}</label>
                                </div>
                            {% endfor %}
                        </div>
                    </div>
                </div>
            </div>

            <div class="form-section">
                <label class="form-label">Available Tricks</label>
                <div class="tricks-container">
                    <div class="tricks-column">
                        <div id="all_tricks" class="tricks-grid">
                            <!-- Tricks will be populated by filterTricks function -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tricks-database">
        <p>Juggler and Open-Source contributor? You can expand the database <a target="_blank" href="https://github.com/ofekraf/jugglefit_website/tree/main/database/tricks">here</a></p>
    </div>

    <!-- Print-only container -->
    <div id="print-container" class="print-only">
        <div class="print-header">
            <h1 id="print-route-name"></h1>
        </div>
        <div id="print-route-content"></div>
    </div>
</div>

<!-- Toast Notification -->
<div id="toast" class="toast-notification"></div>

<!-- Include noUISlider CSS and JS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

<!-- Pass Flask data to JavaScript -->
<script>
    // Toast notification function
    function showToast(message) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => {
            toast.classList.remove('show');
        }, 3000);
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Convert Flask template data to JavaScript objects
        const propToTricksData = '{{ prop_to_tricks|tojson|safe }}';
        const initialRouteData = '{{ initial_route|tojson|default("null")|safe }}';
        
        const propToTricks = JSON.parse(propToTricksData);
        const initialRoute = JSON.parse(initialRouteData);
        
        let currentRoute = {
            name: '',
            prop: '',
            tricks: [],
            duration: 10
        };

        // Initialize route from query parameter if it exists
        if (initialRoute) {
            document.getElementById('route_name').value = initialRoute.name;
            document.getElementById('route_duration').value = initialRoute.duration || 10;
            currentRoute.name = initialRoute.name;
            currentRoute.duration = initialRoute.duration || 10;
            const propInput = document.querySelector(`input[value="${initialRoute.prop}"]`);
            if (propInput) {
                propInput.checked = true;
                currentRoute.prop = initialRoute.prop;
            }
            currentRoute.tricks = initialRoute.tricks;
            updateRouteDisplay();
            filterTricks();
        }

        // Initialize sliders and event listeners
        initializeSliders();
        initializePropSelection();
        initializeEventListeners();

        // Function to initialize sliders
        function initializeSliders() {
            // Props slider initialization
            const propsSlider = document.getElementById('props-slider');
            const propsRange = document.getElementById('props-range');
            const propsMinInput = document.getElementById('min-props-input');
            const propsMaxInput = document.getElementById('max-props-input');
            
            noUiSlider.create(propsSlider, {
                start: [3, 9],
                connect: true,
                range: {
                    'min': 1,
                    'max': 9
                },
                format: {
                    to: (value) => Math.round(value),
                    from: (value) => parseFloat(value)
                }
            });

            propsSlider.noUiSlider.on('update', function(values) {
                propsRange.textContent = `Min: ${values[0]}, Max: ${values[1]}`;
                propsMinInput.value = Math.round(values[0]);
                propsMaxInput.value = Math.round(values[1]);
                filterTricks();
            });

            // Difficulty slider initialization
            const difficultySlider = document.getElementById('difficulty-slider');
            const difficultyRange = document.getElementById('difficulty-range');
            const difficultyMinInput = document.getElementById('min-difficulty-input');
            const difficultyMaxInput = document.getElementById('max-difficulty-input');

            noUiSlider.create(difficultySlider, {
                start: [20, 30],
                connect: true,
                range: {
                    'min': 0,
                    'max': 100
                },
                format: {
                    to: (value) => Math.round(value),
                    from: (value) => parseFloat(value)
                }
            });

            difficultySlider.noUiSlider.on('update', function(values) {
                difficultyRange.textContent = `Min: ${values[0]}, Max: ${values[1]}`;
                difficultyMinInput.value = Math.round(values[0]);
                difficultyMaxInput.value = Math.round(values[1]);
                filterTricks();
            });
        }

        // Function to initialize prop selection
        function initializePropSelection() {
            const propOptions = document.querySelectorAll('.prop-option');
            const propInputs = document.querySelectorAll('.prop-option-input');

            function updateSelectedState() {
                propOptions.forEach(option => {
                    const input = option.querySelector('.prop-option-input');
                    if (input.checked) {
                        option.classList.add('selected');
                        if (currentRoute.prop !== input.value) {
                            currentRoute.tricks = [];
                        }
                        currentRoute.prop = input.value;
                        updateRouteDisplay();
                    } else {
                        option.classList.remove('selected');
                    }
                });
                filterTricks();
            }

            updateSelectedState();

            propOptions.forEach(option => {
                option.addEventListener('click', function() {
                    propInputs.forEach(input => input.checked = false);
                    const input = this.querySelector('.prop-option-input');
                    input.checked = true;
                    updateSelectedState();
                });
            });

            propInputs.forEach(input => {
                input.addEventListener('change', updateSelectedState);
            });
        }

        // Function to initialize other event listeners
        function initializeEventListeners() {
            document.querySelectorAll('input[name="exclude_tags"]').forEach(checkbox => {
                checkbox.addEventListener('change', filterTricks);
            });

            document.getElementById('search').addEventListener('input', filterTricks);

            document.getElementById('route_name').addEventListener('input', function(e) {
                currentRoute.name = e.target.value;
                updateRouteDisplay();
            });

            // Update route duration when input changes
            document.getElementById('route_duration').addEventListener('input', function(e) {
                currentRoute.duration = parseInt(e.target.value);
            });
        }

        // Function to update route display
        function updateRouteDisplay() {
            const routeSections = document.getElementById('route-sections');
            routeSections.innerHTML = '';

            // Group tricks by props count
            const groupedTricks = {};
            currentRoute.tricks.forEach(trick => {
                if (!groupedTricks[trick.props_count]) {
                    groupedTricks[trick.props_count] = [];
                }
                groupedTricks[trick.props_count].push(trick);
            });

            // Create sections for each props count in the order they appear in currentRoute.tricks
            const seenPropCounts = new Set();
            currentRoute.tricks.forEach(trick => {
                if (seenPropCounts.has(trick.props_count)) return;
                seenPropCounts.add(trick.props_count);
                
                const count = trick.props_count;
                const section = document.createElement('div');
                section.className = 'prop-section';
                section.setAttribute('draggable', 'true');
                section.setAttribute('data-props-count', count);
                
                const colorBar = document.createElement('div');
                colorBar.className = 'prop-color-bar';
                colorBar.setAttribute('data-props', count);
                colorBar.setAttribute('data-prop-type', currentRoute.prop);
                
                const propCount = document.createElement('div');
                propCount.className = 'prop-count';
                
                const propCountText = document.createElement('div');
                propCountText.className = 'prop-count-text';
                propCountText.textContent = count;
                
                propCount.appendChild(propCountText);
                colorBar.appendChild(propCount);
                section.appendChild(colorBar);
                
                const trickContainer = document.createElement('div');
                trickContainer.className = 'trick-container';
                trickContainer.setAttribute('data-props-count', count);
                
                groupedTricks[count].forEach(trick => {
                    const frame = document.createElement('div');
                    frame.className = 'prop-details-frame';
                    frame.setAttribute('draggable', 'true');
                    frame.setAttribute('data-trick-name', trick.name);
                    
                    const trickContent = document.createElement('div');
                    trickContent.className = 'trick-content';
                    
                    const name = document.createElement('span');
                    name.className = 'trick-name';
                    name.textContent = trick.name;
                    trickContent.appendChild(name);
                    
                    if (trick.comment) {
                        const comment = document.createElement('span');
                        comment.className = 'trick-comment';
                        comment.textContent = ` - ${trick.comment}`;
                        trickContent.appendChild(comment);
                    }
                    
                    const removeButton = document.createElement('button');
                    removeButton.className = 'remove-trick';
                    removeButton.textContent = 'Ã—';
                    removeButton.onclick = () => removeTrick(trick);
                    trickContent.appendChild(removeButton);
                    
                    frame.appendChild(trickContent);
                    
                    // Add drag and drop event listeners for tricks
                    frame.addEventListener('dragstart', handleDragStart);
                    frame.addEventListener('dragover', handleDragOver);
                    frame.addEventListener('drop', handleDrop);
                    frame.addEventListener('dragend', handleDragEnd);
                    
                    trickContainer.appendChild(frame);
                });
                
                section.appendChild(trickContainer);
                
                // Add drag and drop event listeners for sections
                section.addEventListener('dragstart', handleSectionDragStart);
                section.addEventListener('dragover', handleSectionDragOver);
                section.addEventListener('drop', handleSectionDrop);
                section.addEventListener('dragend', handleSectionDragEnd);
                
                routeSections.appendChild(section);
            });
        }

        // Drag and drop functionality
        let draggedItem = null;
        let draggedSection = null;

        function handleDragStart(e) {
            draggedItem = e.target;
            e.target.classList.add('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
            const frame = e.target.closest('.prop-details-frame');
            if (!frame || frame === draggedItem) return;
            
            const container = frame.parentElement;
            const rect = frame.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            
            if (e.clientY < midY) {
                container.insertBefore(draggedItem, frame);
            } else {
                container.insertBefore(draggedItem, frame.nextSibling);
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('dragging');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedItem = null;
            
            // Update the tricks array to match the new DOM order
            const frames = document.querySelectorAll('.prop-details-frame');
            currentRoute.tricks = Array.from(frames).map(frame => {
                const name = frame.getAttribute('data-trick-name');
                return currentRoute.tricks.find(t => t.name === name);
            });
            
            updateRouteDisplay();
        }

        function handleSectionDragStart(e) {
            draggedSection = e.target.closest('.prop-section');
            draggedSection.classList.add('dragging');
        }

        function handleSectionDragOver(e) {
            e.preventDefault();
            const section = e.target.closest('.prop-section');
            if (!section || section === draggedSection) return;
            
            const container = section.parentElement;
            const rect = section.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            
            if (e.clientY < midY) {
                container.insertBefore(draggedSection, section);
            } else {
                container.insertBefore(draggedSection, section.nextSibling);
            }
        }

        function handleSectionDrop(e) {
            e.preventDefault();
            e.target.classList.remove('dragging');
        }

        function handleSectionDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedSection = null;
            
            // Update the tricks array to match the new section order
            const sections = document.querySelectorAll('.prop-section');
            const newTricks = [];
            sections.forEach(section => {
                const frames = section.querySelectorAll('.prop-details-frame');
                frames.forEach(frame => {
                    const name = frame.getAttribute('data-trick-name');
                    const trick = currentRoute.tricks.find(t => t.name === name);
                    if (trick) newTricks.push(trick);
                });
            });
            currentRoute.tricks = newTricks;
        }

        function addTrickToRoute(trick) {
            // Check if a trick with the same name and props_count already exists
            const isDuplicate = currentRoute.tricks.some(t => 
                t.name === trick.name && t.props_count === trick.props_count
            );
            
            if (isDuplicate) {
                showToast('This trick is already in your route.');
                return;
            }
            
            currentRoute.tricks.push(trick);
            updateRouteDisplay();
        }

        // Function to remove trick from route
        function removeTrick(trick) {
            currentRoute.tricks = currentRoute.tricks.filter(t => t.name !== trick.name);
            updateRouteDisplay();
        }

        // Initial filter and update tricks
        filterTricks();

        function filterTricks() {
            const searchTerm = document.getElementById('search')?.value?.toLowerCase() || '';
            const selectedProp = document.querySelector('input[name="prop"]:checked')?.value;
            const minProps = parseInt(document.getElementById('min-props-input').value);
            const maxProps = parseInt(document.getElementById('max-props-input').value);
            const minDifficulty = parseInt(document.getElementById('min-difficulty-input').value);
            const maxDifficulty = parseInt(document.getElementById('max-difficulty-input').value);
            const excludedTags = Array.from(document.querySelectorAll('input[name="exclude_tags"]:checked')).map(cb => cb.value);

            // Get tricks for the selected prop
            const tricks = propToTricks[selectedProp] || [];

            // Filter tricks based on all criteria
            const filteredTricks = tricks.filter(trick => {
                // Check if trick name matches search term
                const nameMatch = trick.name.toLowerCase().includes(searchTerm);
                
                // Check if props count is within range
                const propsCountMatch = trick.props_count >= minProps && trick.props_count <= maxProps;
                
                // Check if difficulty is within range
                const difficultyMatch = trick.difficulty >= minDifficulty && trick.difficulty <= maxDifficulty;
                
                // Check if trick doesn't have any excluded tags
                const tagsMatch = !excludedTags.some(tag => trick.tags.includes(tag));
                
                return nameMatch && propsCountMatch && difficultyMatch && tagsMatch;
            });

            // Group filtered tricks by props count
            const groupedTricks = {};
            filteredTricks.forEach(trick => {
                if (!groupedTricks[trick.props_count]) {
                    groupedTricks[trick.props_count] = [];
                }
                groupedTricks[trick.props_count].push(trick);
            });

            // Update the tricks display
            const tricksGrid = document.getElementById('all_tricks');
            tricksGrid.innerHTML = '';

            // Display tricks grouped by props count
            Object.keys(groupedTricks).sort((a, b) => parseInt(a) - parseInt(b)).forEach(count => {
                const group = document.createElement('div');
                group.className = 'props-group';
                
                const header = document.createElement('h3');
                header.className = 'props-count-header';
                header.textContent = `${count} Props`;
                group.appendChild(header);
                
                const tricksList = document.createElement('div');
                tricksList.className = 'tricks-list';
                
                // Sort tricks by name within each group
                groupedTricks[count].sort((a, b) => a.name.localeCompare(b.name)).forEach(trick => {
                    const trickItem = document.createElement('div');
                    trickItem.className = 'trick-item';
                    
                    const trickName = document.createElement('div');
                    trickName.className = 'trick-name';
                    trickName.textContent = trick.name;
                    trickItem.appendChild(trickName);
                    
                    if (trick.comment) {
                        const trickComment = document.createElement('div');
                        trickComment.className = 'trick-comment';
                        trickComment.textContent = trick.comment;
                        trickItem.appendChild(trickComment);
                    }
                    
                    const addButton = document.createElement('button');
                    addButton.className = 'add-trick';
                    addButton.textContent = 'Add';
                    addButton.onclick = () => addTrickToRoute(trick);
                    trickItem.appendChild(addButton);
                    
                    tricksList.appendChild(trickItem);
                });
                
                group.appendChild(tricksList);
                tricksGrid.appendChild(group);
            });
        }

        // Add Custom Trick functionality
        document.getElementById('add_custom_trick').addEventListener('click', function() {
            const name = document.getElementById('custom_trick_name').value.trim();
            const propsCount = parseInt(document.getElementById('custom_trick_props').value);
            const comment = document.getElementById('custom_trick_comment').value.trim();

            if (!name) {
                alert('Please enter a trick name');
                return;
            }

            if (isNaN(propsCount) || propsCount < 1 || propsCount > 9) {
                alert('Please enter a valid props count between 1 and 9');
                return;
            }

            const customTrick = {
                name: name,
                props_count: propsCount,
                difficulty: 30, // Default difficulty
                tags: [], // No tags by default
                comment: comment || null
            };

            addTrickToRoute(customTrick);

            // Clear the form
            document.getElementById('custom_trick_name').value = '';
            document.getElementById('custom_trick_props').value = '3';
            document.getElementById('custom_trick_comment').value = '';
        });

        // Export route functionality
        document.getElementById('export_route').addEventListener('click', function() {
            if (!currentRoute.name) {
                showToast('Please enter a route name before copying the URL.');
                document.getElementById('route_name').focus();
                return;
            }
            if (!currentRoute.prop) {
                showToast('Please select a prop type before copying the URL.');
                return;
            }
            if (currentRoute.tricks.length === 0) {
                showToast('Please add some tricks to your route before copying the URL.');
                return;
            }

            const route = {
                name: currentRoute.name,
                prop: currentRoute.prop,
                duration: currentRoute.duration * 60, // Convert minutes to seconds
                tricks: currentRoute.tricks
            };

            // Create a Route instance and serialize it
            fetch('/api/serialize_route', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(route)
            })
            .then(response => response.text())
            .then(serialized => {
                const url = new URL(window.location.href);
                url.searchParams.set('route', serialized);
                
                // Copy to clipboard
                navigator.clipboard.writeText(url.toString())
                    .then(() => {
                        showToast('Route URL copied to clipboard!');
                    })
                    .catch(() => {
                        // If clipboard copy fails, show the URL
                        showToast('Failed to copy to clipboard. Please copy the URL manually.');
                        setTimeout(() => {
                            prompt('Copy this URL to share your route:', url.toString());
                        }, 1000);
                    });
            });
        });

        // View route functionality
        document.getElementById('view_route').addEventListener('click', async function() {
            if (!currentRoute.name) {
                showToast('Please enter a route name before viewing.');
                document.getElementById('route_name').focus();
                return;
            }
            if (!currentRoute.prop) {
                showToast('Please select a prop type before viewing.');
                return;
            }
            if (currentRoute.tricks.length === 0) {
                showToast('Please add some tricks to your route before viewing.');
                return;
            }

            try {
                // Serialize the route
                const response = await fetch('/api/serialize_route', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(currentRoute)
                });
                const serialized = await response.text();
                
                // Redirect to the created_route page with the serialized route
                window.location.href = `/created_route?route=${encodeURIComponent(serialized)}`;
            } catch (error) {
                console.error('Error preparing route for viewing:', error);
                showToast('Error preparing route for viewing. Please try again.');
            }
        });
    });
</script>
{% endblock %}
