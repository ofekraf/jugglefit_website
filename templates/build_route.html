{% extends "macros/base.html" %}

{% block head %}
<script>
// Trick filtering constants from Flask context
window.MIN_TRICK_DIFFICULTY = {{ MIN_TRICK_DIFFICULTY }};
window.MAX_TRICK_DIFFICULTY = {{ MAX_TRICK_DIFFICULTY }};
</script>
<script>
// Make props settings available globally for macros
const propsSettings = {{ props_settings|tojson|safe }};
window.propsSettings = propsSettings;
</script>
<script>
// Initialize window.currentRoute properly
window.currentRoute = { name: '', duration_seconds: 600, prop: '', tricks: [] };
</script>
<script>
// Expose initial_route from Flask as window.initialRoute for JS
{% if initial_route %}
window.initialRoute = {{ initial_route|tojson|safe }};
{% else %}
window.initialRoute = null;
{% endif %}

// Initialize currentRoute from initial_route if available
if (window.initialRoute && window.initialRoute.tricks) {
    window.currentRoute = {
        name: window.initialRoute.name || '',
        duration_seconds: window.initialRoute.duration_seconds || 600,
        prop: window.initialRoute.prop || '',
        tricks: window.initialRoute.tricks || []
    };
}
</script>
{% endblock %}

{% block title %}Create Your Own Route{% endblock %}
{% block content %}
<div class="route-page">
    <div class="route-header">
        <h1 class="route-title">Build Your Route</h1>
        <div class="route-description">
            <p>Create a custom route by selecting tricks.</p>
        </div>
        <div class="siteswap-x-toggle-row center-row">
            <label class="siteswap-x-toggle-label">
                <input type="checkbox" id="toggle-siteswap-x-checkbox" class="siteswap-x-toggle-checkbox"> Siteswap-X
            </label>
        </div>
    </div>

    {% from 'macros/route_name_input.html' import route_name_input %}
    {% from 'macros/prop_selection_macro.html' import prop_selection_macro %}
    {% from 'macros/number_of_props_macro.html' import number_of_props_macro %}
    {% from 'macros/difficulty_range_macro.html' import difficulty_range_macro %}
    {% from 'macros/route_duration_macro.html' import route_duration_macro %}
    {% from 'macros/limit_max_throw_macro.html' import limit_max_throw_macro %}
    {% from 'macros/relevant_tags_macro.html' import relevant_tags_macro %}
    {% from 'macros/available_tricks_macro.html' import available_tricks_macro %}

    <div class="route-form">
        {{ route_name_input() }}
        {{ route_duration_macro() }}

        {{ prop_selection_macro(props_settings, main_props, initial_route.prop if initial_route else None) }}

        <!-- Route Display -->
        <div class="form-section">
            <div class="route-container">
                <div class="route-content">
                    {% if initial_route %}
                        {% set route = initial_route %}
                        {% include "macros/route_display.html" %}
                    {% else %}
                        <div id="route-sections" class="route-sections"></div>
                    {% endif %}
                </div>
            </div>
            <div class="route-actions">
                <div class="route-buttons">
                    <button type="button" id="view_route" class="primary-button">View Route</button>
                </div>
            </div>
        </div>

        <!-- Add Custom Trick Section -->
        <div class="form-section custom-trick-section">
            <h4 class="subsection-title">Add Custom Trick</h4>
            <div class="custom-trick-form">
                <div class="form-row">
                    <div class="form-group">
                        <label for="custom_trick_name">Trick Name</label>
                        <input type="text" id="custom_trick_name" class="form-input" placeholder="Enter trick name">
                    </div>
                    <div class="form-group">
                        <label for="custom_trick_siteswap">Siteswap-X</label>
                        <input type="text" id="custom_trick_siteswap" class="form-input" placeholder="Enter siteswap-x notation">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="custom_trick_props">Number of Props</label>
                        <div class="slider-container">
                            <div class="slider-wrapper">
                                <input type="range" id="custom_trick_props" class="custom-range" min="1" max="{{ MAX_TRICK_PROPS_COUNT }}" value="3">
                                <span id="custom_trick_props_value" class="slider-value">3</span>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="custom_trick_comment">Comment (Optional)</label>
                        <textarea id="custom_trick_comment" class="form-input" placeholder="Add a comment about the trick"></textarea>
                    </div>
                </div>
                <button type="button" id="add_custom_trick" class="add-trick">Add</button>
            </div>
        </div>

        <div class="form-section">
            <div class="route-form">
                <h4 class="subsection-title">Add Tricks</h4>
                {{ number_of_props_macro() }}
                {{ difficulty_range_macro() }}
                {{ limit_max_throw_macro(props_settings) }}
                {{ relevant_tags_macro(tag_category_map, 'available') }}
                {{ available_tricks_macro() }}
            </div>
        </div>
    </div>
</div>

<!-- Toast Notification -->
<div id="toast" class="toast-notification"></div>

<!-- Include noUISlider CSS and JS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<script src="{{ url_for('static', filename='js/general.js') }}"></script>
<script src="{{ url_for('static', filename='js/siteswap_x.js') }}"></script>

<script type="module">
    try {
        const { fetchTricks, updatePropsSliderRange, updateRelevantTags, setMaxThrowForProp, initMaxThrowBindings, initializePropSelection, refreshFromRoute, updateRouteDisplay, addTrickToRoute, removeTrick, updateCustomTrickPropsRange } = await import("{{ url_for('static', filename='js/route_helpers.js') }}");
        
        // Make functions available globally for non-module scripts and macros
        window.fetchTricks = fetchTricks;
        window.updateRelevantTags = updateRelevantTags;
        window.setMaxThrowForProp = setMaxThrowForProp;
        window.updatePropsSliderRange = updatePropsSliderRange;
        window.initializePropSelection = initializePropSelection;
        window.refreshFromRoute = refreshFromRoute;
        window.updateRouteDisplay = updateRouteDisplay;
        window.addTrickToRoute = addTrickToRoute;
        window.removeTrick = removeTrick;
        window.updateCustomTrickPropsRange = updateCustomTrickPropsRange;
        
        // Initialize max throw bindings
        initMaxThrowBindings();
        
        // Check for siteswap-x URL parameter and set checkbox immediately
        const urlParams = new URLSearchParams(window.location.search);
        const siteswapXParam = urlParams.get('siteswapx');
        if (siteswapXParam === '1') {
            const siteswapToggle = document.getElementById('toggle-siteswap-x-checkbox');
            if (siteswapToggle) {
                siteswapToggle.checked = true;
            }
        }
        
        // Initialize prop selection immediately if functions are available
        if (typeof window.initializePropSelection === 'function') {
            window.initializePropSelection();
        }
        
        const event = new CustomEvent('routeHelpersReady');
        document.dispatchEvent(event);
        
    } catch (error) {
        // Failed to import route helpers
    }
</script>

<!-- Inlined route initialization logic (previously in macros/route_initialization_macro.html) -->
<script>
(function() {
    'use strict';
    
    function initializeFromInitialRoute(initialRoute) {
        
        // Set route name immediately without delay
        const routeNameInput = document.getElementById('route_name');
        if (routeNameInput) {
            routeNameInput.value = initialRoute.name || '';
            routeNameInput.dispatchEvent(new Event('input', { bubbles: true }));
        }

        window.currentRoute.name = initialRoute.name || '';

        // Set duration
        const durationMinutes = Math.floor(initialRoute.duration_seconds / 60);
        const durationSlider = document.getElementById('route-duration-slider');
        const durationValue = document.getElementById('route-duration-value');
        
        if (durationSlider) durationSlider.value = durationMinutes;
        if (durationValue) durationValue.textContent = durationMinutes;
        window.currentRoute.duration_seconds = initialRoute.duration_seconds;

        // Set prop type
        window.currentRoute.prop = initialRoute.prop;
        const propInput = document.querySelector(`input[value="${initialRoute.prop}"]`);
        if (propInput) {
            propInput.checked = true;
            const propOption = propInput.closest('.prop-option');
            if (propOption) {
                propOption.classList.add('selected');
            }
            
            // Set tricks from initial route
            window.currentRoute.tricks = initialRoute.tricks || [];
            
            // Initialize prop-specific functionality for the initial route prop
            const propSettings = window.propsSettings && window.propsSettings[initialRoute.prop];
            if (propSettings) {
                // Update relevant tags for this prop
                if (typeof window.updateRelevantTags === 'function') {
                    window.updateRelevantTags(propSettings.relevant_tags, 'available');
                }
                
                // Set max throw for this prop
                if (typeof window.setMaxThrowForProp === 'function') {
                    window.setMaxThrowForProp(propSettings);
                }
                
                // Update custom trick props range for initial route
                if (typeof window.updateCustomTrickPropsRange === 'function') {
                    window.updateCustomTrickPropsRange(propSettings.min_props, propSettings.max_props);
                }
            }
            
            // Update route display after setting tricks
            if (typeof window.updateRouteDisplay === 'function') {
                window.updateRouteDisplay();
            }
        } else {
            // Set tricks if no prop input found
            window.currentRoute.tricks = initialRoute.tricks || [];
            if (typeof window.updateRouteDisplay === 'function') {
                window.updateRouteDisplay();
            }
        }
    }
    
    function initializeEventListeners() {
        
        // Route name input - simple: change currentRoute and refresh
        const routeNameInput = document.getElementById('route_name');
        if (routeNameInput) {
            routeNameInput.addEventListener('input', function(e) {
                if (window.currentRoute) {
                    window.currentRoute.name = e.target.value;
                    // Only refresh route display, not all GUI (avoid cursor jumping)
                    if (typeof window.updateRouteDisplay === 'function') {
                        window.updateRouteDisplay();
                    }
                }
            });
        }

        // Route duration slider - simple: change currentRoute and refresh
        const routeDurationSlider = document.getElementById('route-duration-slider');
        
        if (routeDurationSlider) {
            routeDurationSlider.addEventListener('input', () => {
                const minutes = parseInt(routeDurationSlider.value);
                if (window.currentRoute) {
                    window.currentRoute.duration_seconds = minutes * 60;
                    if (typeof window.refreshFromRoute === 'function') {
                        window.refreshFromRoute();
                    }
                }
            });
        }

        // Siteswap-X toggle
        const siteswapToggle = document.getElementById('toggle-siteswap-x-checkbox');
        if (siteswapToggle) {
            siteswapToggle.addEventListener('change', function() {
                if (typeof window.toggleSiteswapXEverywhere === 'function') {
                    window.toggleSiteswapXEverywhere();
                }
            });
        }

        // Available tricks filters
        const maxThrowInput = document.getElementById('max-throw-input');
        if (maxThrowInput) {
            maxThrowInput.addEventListener('input', () => {
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        }

        // Prop selection radio buttons - initialize tricks and tags when prop is selected
        document.querySelectorAll('input[name="prop"]').forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked && typeof window.initializePropSelection === 'function') {
                    window.initializePropSelection();
                }
            });
        });

        // Wait for route helpers to be ready before initializing
        function initializeWhenReady() {
            const currentlySelectedProp = document.querySelector('input[name="prop"]:checked');
            if (currentlySelectedProp && typeof window.initializePropSelection === 'function') {
                window.initializePropSelection();
            } else if (currentlySelectedProp) {
                setTimeout(initializeWhenReady, 100);
            }
        }

        // Listen for route helpers ready event
        document.addEventListener('routeHelpersReady', initializeWhenReady);
        
        // Also try immediate initialization in case the event already fired
        setTimeout(initializeWhenReady, 50);

        // Debug function accessible from console
        window.debugInitialization = function() {
            const selectedProp = document.querySelector('input[name="prop"]:checked');
            if (selectedProp && typeof window.initializePropSelection === 'function') {
                window.initializePropSelection();
            }
        };
        
        // Manual trigger function
        window.manualInit = function() {
            initializeWhenReady();
        };

        // Exclude tags for available tricks
        document.querySelectorAll('input[name="exclude_tags_available"]').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Category checkboxes for available tricks
        document.querySelectorAll('.category-checkbox-available').forEach(checkbox => {
            checkbox.addEventListener('change', function(e) {
                e.stopPropagation();
                const category = this.id.replace('category-available-', '');
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox-available[data-category="${category}"]`);
                relatedCheckboxes.forEach(cb => {
                    cb.checked = this.checked;
                });
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Update category checkbox when individual tags change (available tricks)
        document.querySelectorAll('.tag-checkbox-available').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const category = this.dataset.category;
                const categoryCheckbox = document.getElementById(`category-available-${category}`);
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox-available[data-category="${category}"]`);
                const allChecked = Array.from(relatedCheckboxes).every(cb => cb.checked);
                const someChecked = Array.from(relatedCheckboxes).some(cb => cb.checked);
                if (categoryCheckbox) {
                    categoryCheckbox.checked = allChecked;
                    categoryCheckbox.indeterminate = someChecked && !allChecked;
                }
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Custom trick functionality
        const addCustomTrickBtn = document.getElementById('add_custom_trick');
        if (addCustomTrickBtn) {
            addCustomTrickBtn.addEventListener('click', function() {
                const name = document.getElementById('custom_trick_name').value.trim();
                const siteswapX = document.getElementById('custom_trick_siteswap').value.trim();
                const propsCount = parseInt(document.getElementById('custom_trick_props').value);
                const comment = document.getElementById('custom_trick_comment').value.trim();


                // Validation: must have at least name or siteswap-x
                if (!name && !siteswapX) {
                    if (typeof window.showToast === 'function') {
                        window.showToast('Please enter either a trick name or siteswap-x notation', 'custom_trick_name');
                    }
                    return;
                }

                const customTrick = {
                    name: name || null,  // Keep name as null if not provided, don't default to 'Custom Trick'
                    siteswap_x: siteswapX || null,
                    props_count: propsCount,
                    difficulty: 30,
                    tags: [],
                    comment: comment || null
                };


                if (typeof window.addTrickToRoute === 'function') {
                    window.addTrickToRoute(customTrick);
                } else {
                    // Fallback to direct addition
                    if (!window.currentRoute) {
                        window.currentRoute = { name: '', duration_seconds: 600, prop: '', tricks: [] };
                    }
                    window.currentRoute.tricks.push(customTrick);
                    if (typeof window.refreshFromRoute === 'function') {
                        window.refreshFromRoute();
                    }
                }

                // Clear the input fields
                document.getElementById('custom_trick_name').value = '';
                document.getElementById('custom_trick_siteswap').value = '';
                document.getElementById('custom_trick_comment').value = '';
            });
        }

        // Custom trick props slider
        const customTrickPropsSlider = document.getElementById('custom_trick_props');
        const customTrickPropsValue = document.getElementById('custom_trick_props_value');
        if (customTrickPropsSlider && customTrickPropsValue) {
            customTrickPropsValue.textContent = parseInt(customTrickPropsSlider.value);
            customTrickPropsSlider.addEventListener('input', () => {
                const value = parseInt(customTrickPropsSlider.value);
                customTrickPropsValue.textContent = value;
            });
        }

        // View route functionality
        const viewRouteBtn = document.getElementById('view_route');
        if (viewRouteBtn) {
            viewRouteBtn.addEventListener('click', handleViewRoute);
        }

        // Tag category functionality
        document.querySelectorAll('.tag-category-title').forEach(title => {
            title.addEventListener('click', function(e) {
                if (e.target.type === 'checkbox') return;
                
                const header = this.closest('.tag-category-header');
                const content = header ? header.nextElementSibling : null;
                if (content) content.classList.toggle('expanded');
            });
        });

        // Category checkbox functionality
        document.querySelectorAll('.category-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function(e) {
                e.stopPropagation();
                
                const category = this.id.replace('category-', '');
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox[data-category="${category}"]`);
                relatedCheckboxes.forEach(cb => {
                    cb.checked = this.checked;
                });
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });

        // Update category checkbox when individual tags change
        document.querySelectorAll('.tag-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const category = this.dataset.category;
                const categoryCheckbox = document.getElementById(`category-${category}`);
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox[data-category="${category}"]`);
                const allChecked = Array.from(relatedCheckboxes).every(cb => cb.checked);
                const someChecked = Array.from(relatedCheckboxes).some(cb => cb.checked);
                if (categoryCheckbox) {
                    categoryCheckbox.checked = allChecked;
                    categoryCheckbox.indeterminate = someChecked && !allChecked;
                }
                
                if (typeof window.updateSearchTricks === 'function') {
                    window.updateSearchTricks();
                }
            });
        });
    }
    
    function setupRouteHelpers() {
        // Removed all initialization logic that was destroying the UI
        // The props slider and other UI elements are already initialized by their respective macros
    }
    
    async function handleViewRoute() {
        // Pull the typed route name into currentRoute before validating
        const typedName = document.getElementById('route_name') ? document.getElementById('route_name').value.trim() : '';
        if (typedName) {
            window.currentRoute.name = typedName;
        }
        
        // If no name was entered, show a non-blocking toast but allow viewing the route
        if (!window.currentRoute.name) {
            if (typeof window.showToast === 'function') {
                window.showToast('No route name provided. Proceeding to view without a name.');
            }
        }
        
        if (!window.currentRoute.prop) {
            if (typeof window.showToast === 'function') {
                window.showToast('Please select a prop type before viewing.', 'prop-slider');
            }
            return;
        }

        try {
            // Build a complete payload for serialization
            const durationSeconds = window.currentRoute.duration_seconds || 600;
            
            // Get tricks from currentRoute
            const allTricks = Array.isArray(window.currentRoute.tricks) ? window.currentRoute.tricks : [];
            
            const payload = {
                name: window.currentRoute.name,
                prop: window.currentRoute.prop,
                duration_seconds: durationSeconds,
                tricks: allTricks.map(t => ({
                    name: t.name,
                    siteswap_x: t.siteswap_x || null,
                    props_count: t.props_count,
                    difficulty: t.difficulty,
                    tags: t.tags || [],
                    comment: t.comment || null
                }))
            };

            // Serialize the route directly in the browser
            const jsonString = JSON.stringify(payload);
            const compressed = pako.deflate(jsonString);
            const serialized = btoa(String.fromCharCode.apply(null, compressed));
            
            // Check if siteswap-x is enabled and add URL param
            const siteswapToggle = document.getElementById('toggle-siteswap-x-checkbox');
            const siteswapXEnabled = siteswapToggle && siteswapToggle.checked;
            
            // Redirect to the created_route page with the serialized route
            const encodedRoute = encodeURIComponent(serialized);
            const url = siteswapXEnabled
                ? `/created_route?route=${encodedRoute}&siteswapx=1`
                : `/created_route?route=${encodedRoute}`;
            
            window.location.href = url;
        } catch (error) {
            if (typeof window.showToast === 'function') {
                window.showToast('Error preparing route for viewing. Please try again.');
            }
        }
    }
    
    // Export main delegation function
    window.updateSearchTricks = function() {
        if (typeof window.UpdateAvailableTricks === 'function') {
            window.UpdateAvailableTricks();
        }
    };
    
    // Call initializeEventListeners when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeEventListeners);
    } else {
        initializeEventListeners();
    }
    
})();
</script>

<!-- Removed backup implementation that was using setTimeout -->
</div>
{% endblock %}

