{% extends "macros/base.html" %}
{% block title %}Create Your Own Route{% endblock %}
{% block content %}
<div class="route-page">
    <div class="route-header">
        <h1 class="route-title">Generate New Route</h1>
        <div class="route-description">
            <p>Customize your route by selecting props, difficulty, and length. Get a personalized sequence of tricks to practice.</p>
        </div>
    </div>

    {% from 'macros/route_name_input.html' import route_name_input %}
    {% from 'macros/prop_selection_macro.html' import prop_selection_macro %}
    {% from 'macros/number_of_props_macro.html' import number_of_props_macro %}
    {% from 'macros/difficulty_range_macro.html' import difficulty_range_macro %}
    {% from 'macros/number_of_tricks_macro.html' import number_of_tricks_macro %}
    {% from 'macros/route_duration_macro.html' import route_duration_macro %}
    {% from 'macros/limit_max_throw_macro.html' import limit_max_throw_macro %}
    {% from 'macros/relevant_tags_macro.html' import relevant_tags_macro %}

    <form method="POST" action="{{ url_for('generate_route') }}" class="route-form">
        {{ route_name_input() }}
        {{ prop_selection_macro(props_settings, main_props) }}
        {{ number_of_props_macro() }}
        {{ difficulty_range_macro() }}
        {{ number_of_tricks_macro() }}
        {{ route_duration_macro() }}
        {{ limit_max_throw_macro(props_settings) }}
        {{ relevant_tags_macro(tag_category_map) }}

        <div class="form-actions">
            <button type="submit" class="primary-button">Generate Route</button>
        </div>
    </form>

    <div class="tricks-database">
        <p>Tricks are repeating? Missing variety?</p>
        <p>Add new tricks to the database <a href="{{ url_for('expand_database') }}">here</a></p>
    </div>
</div>

<!-- Include noUISlider CSS and JS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
<script src="{{ url_for('static', filename='js/siteswap_x.js') }}"></script>
<script type="module">
    import { fetchTricks, updatePropsSliderRange, updateRelevantTags, setMaxThrowForProp, initMaxThrowBindings } from "{{ url_for('static', filename='js/route_helpers.js') }}";

    // Props settings from Flask
    const propsSettings = {{ props_settings|tojson|safe }};
    // Expose globally for macros that initialize sliders and helpers
    window.propsSettings = propsSettings;
    const propsSlider = document.getElementById('props-slider');
    const propsRange = document.getElementById('props-range');
    const propsMinInput = document.getElementById('min-props-input');
    const propsMaxInput = document.getElementById('max-props-input');
    // Max throw elements (move to top so all handlers can use them)
    const maxThrowEnabled = document.getElementById('max-throw-enabled');
    const maxThrowContainer = document.getElementById('max-throw-input-container');
    const maxThrowSlider = document.getElementById('max-throw-slider');
    const maxThrowValue = document.getElementById('max-throw-value');
    const maxThrowInput = document.getElementById('max-throw-input');

    // Get initial prop (first selected). If none selected yet, fall back to the first key in propsSettings.
    const checkedPropInput = document.querySelector('.prop-option-input:checked');
    let selectedProp = checkedPropInput ? checkedPropInput.value : Object.keys(propsSettings)[0];
    let propSettings = propsSettings[selectedProp];
    let minProps = propSettings.min_props;
    let maxProps = propSettings.max_props;


    // Handler for prop change: updates all prop-dependent UI and fetches tricks
    function handlePropChange() {
        const selectedInput = document.querySelector('.prop-option-input:checked');
        if (!selectedInput) return;
        const prop = selectedInput.value;
        const propSettings = propsSettings[prop];
        const minProps = propSettings.min_props;
        const maxProps = propSettings.max_props;

        // Update slider range via helper imported from module
        updatePropsSliderRange(minProps, maxProps);
        propsRange.textContent = `Min: ${minProps}, Max: ${maxProps}`;
        propsMinInput.value = minProps;
        propsMaxInput.value = maxProps;

        // Update relevant tags via imported helper
        updateRelevantTags(propSettings.relevant_tags, '');

        // Use centralized max-throw handler
    console.debug('Calling setMaxThrowForProp with', propSettings);
    try { setMaxThrowForProp(propSettings); } catch (e) { console.error('setMaxThrowForProp error', e); }

        // Fetch tricks for selected prop and current max throw
        const maxThrowElem = document.getElementById('max-throw-enabled');
        const maxThrow = maxThrowElem && maxThrowElem.checked ? parseInt(document.getElementById('max-throw-input').value) : null;
        // Build request payload with numeric values where available. Use propSettings' min/max props by default.
        const minPropsValue = Number.isFinite(Number(propSettings.min_props)) ? Number(propSettings.min_props) : null;
        const maxPropsValue = Number.isFinite(Number(propSettings.max_props)) ? Number(propSettings.max_props) : null;
        const _minDifficulty = parseInt(document.getElementById('min-difficulty-input').value);
        const _maxDifficulty = parseInt(document.getElementById('max-difficulty-input').value);
        const minDifficultyValue = Number.isFinite(_minDifficulty) ? _minDifficulty : null;
        const maxDifficultyValue = Number.isFinite(_maxDifficulty) ? _maxDifficulty : null;
        const excludedTags = Array.from(document.querySelectorAll('input[name="exclude_tags"]:checked')).map(cb => cb.value);

        // Load all tricks for this prop (no client-side filters yet). Filtering is applied later when generating routes/tooltips.
        fetchTricks({ propType: prop })
            .then(tricks => { window.allTricks = tricks; })
            .catch(error => { console.error('Error fetching tricks:', error); });
    }


    // Attach handler to all prop radio inputs and update .selected class
    document.querySelectorAll('.prop-option-input').forEach(input => {
        input.addEventListener('change', function() {
            // Update .selected class on prop labels
            document.querySelectorAll('.prop-option').forEach(label => {
                const radio = label.querySelector('.prop-option-input');
                if (radio.checked) {
                    label.classList.add('selected');
                } else {
                    label.classList.remove('selected');
                }
            });
            handlePropChange();
        });
    });
    // max-throw handlers are implemented inside the limit_max_throw_macro

    // On page load, select the first prop and trigger change to initialize UI
    document.addEventListener('DOMContentLoaded', function() {
        const firstPropInput = document.querySelector('.prop-option-input');
        if (firstPropInput) {
            // Ensure the radio is checked and UI initialized
            firstPropInput.checked = true;
            const label = firstPropInput.closest('.prop-option');
            if (label) label.classList.add('selected');
            if (typeof handlePropChange === 'function') {
                handlePropChange();
            }
            // Ensure max-throw bindings are active (idempotent)
            try { initMaxThrowBindings(); } catch (e) { console.error('initMaxThrowBindings error', e); }
        }
    });

    // Difficulty slider and props slider initialization moved into macros
    const difficultySlider = document.getElementById('difficulty-slider');
    const difficultyRange = document.getElementById('difficulty-range');  
    const difficultyMinInput = document.getElementById('min-difficulty-input');
    const difficultyMaxInput = document.getElementById('max-difficulty-input');

    // Store all tricks for the current prop type
    window.allTricks = [];

    // Function to show trick tooltip
    function showTrickTooltip(event, difficulty) {
        if (!Array.isArray(allTricks) || allTricks.length === 0) return;
        const minProps = parseInt(document.getElementById('min-props-input').value);
        const maxProps = parseInt(document.getElementById('max-props-input').value);
        const excludedTags = Array.from(document.querySelectorAll('input[name="exclude_tags"]:checked')).map(cb => cb.value);
        const currentPropInput = document.querySelector('.prop-option-input:checked');
        const currentProp = currentPropInput ? currentPropInput.value : null;

        // Determine maxThrow from checkbox/slider and get a random trick respecting it
        const maxThrowElem = document.getElementById('max-throw-enabled');
        const tooltipMaxThrow = maxThrowElem && maxThrowElem.checked ? parseInt(document.getElementById('max-throw-input').value) : null;
        // Get a random trick for the current difficulty
        const trick = getRandomTrickForDifficulty(allTricks, difficulty, minProps, maxProps, excludedTags, tooltipMaxThrow);
        if (!trick) return;

        // Remove any existing tooltip
        const existingTooltip = document.querySelector('.trick-tooltip');
        if (existingTooltip) {
            existingTooltip.remove();
        }

        const tooltip = document.createElement('div');
        tooltip.className = 'trick-tooltip';
        tooltip.textContent = `${trick.props_count} ${currentProp}: ${trick.name}`;
        
        // Position the tooltip near the cursor
        tooltip.style.left = `${event.clientX + 10}px`;
        tooltip.style.top = `${event.clientY + 10}px`;
        
        document.body.appendChild(tooltip);
    }

    // Update the difficulty range display (only if slider exists)
    if (difficultySlider && difficultySlider.noUiSlider) {
        difficultySlider.noUiSlider.on('update', function(values) {
            difficultyRange.textContent = `Min: ${values[0]}, Max: ${values[1]}`;
            difficultyMinInput.value = Math.round(values[0]);
            difficultyMaxInput.value = Math.round(values[1]);
        });
    }

    // Difficulty slider hover/tooltip handled inside the difficulty_range_macro

    // Update the value displayed next to the "Number of Tricks" slider
    const routeLengthSlider = document.getElementById('route-length-slider');
    const routeLengthValue = document.getElementById('route-length-value');
    const routeLengthInput = document.getElementById('route-length-input');
    routeLengthSlider.addEventListener('input', () => {
        routeLengthValue.textContent = routeLengthSlider.value;
        routeLengthInput.value = routeLengthSlider.value;
    });

    // Update the value displayed next to the "Route Duration" slider
    const routeDurationSlider = document.getElementById('route-duration-slider');
    const routeDurationValue = document.getElementById('route-duration-value');
    const routeDurationInput = document.getElementById('route-duration-input');
    routeDurationSlider.addEventListener('input', () => {
        const minutes = parseInt(routeDurationSlider.value);
        routeDurationValue.textContent = minutes;
        routeDurationInput.value = minutes;
    });

    // Max Throw UI is handled by the limit_max_throw_macro

    // Tag interactions are handled by the relevant_tags_macro
</script>
{% endblock %}
