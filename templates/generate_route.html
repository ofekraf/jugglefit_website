{% extends "macros/base.html" %}
{% block title %}Create Your Own Route{% endblock %}
{% block content %}
<div class="route-page">
    <div class="route-header">
        <h1 class="route-title">Generate New Route</h1>
        <div class="route-description">
            <p>Customize your route by selecting props, difficulty, and length. Get a personalized sequence of tricks to practice.</p>
        </div>
    </div>

    {% from 'macros/route_name_input.html' import route_name_input %}
    {% from 'macros/prop_selection_macro.html' import prop_selection_macro %}
    {% from 'macros/number_of_props_macro.html' import number_of_props_macro %}
    {% from 'macros/difficulty_range_macro.html' import difficulty_range_macro %}
    {% from 'macros/number_of_tricks_macro.html' import number_of_tricks_macro %}
    {% from 'macros/route_duration_macro.html' import route_duration_macro %}
    {% from 'macros/limit_max_throw_macro.html' import limit_max_throw_macro %}
    {% from 'macros/relevant_tags_macro.html' import relevant_tags_macro %}

    <form method="POST" action="{{ url_for('generate_route') }}" class="route-form">
        {{ route_name_input() }}
        {{ prop_selection_macro(props_settings, main_props) }}
        {{ number_of_props_macro() }}
        {{ difficulty_range_macro() }}
        {{ number_of_tricks_macro() }}
        {{ route_duration_macro() }}
        {{ limit_max_throw_macro(props_settings) }}
        {{ relevant_tags_macro(tag_category_map) }}

        <div class="form-actions">
            <button type="submit" class="primary-button">Generate Route</button>
        </div>
    </form>

    <div class="tricks-database">
        <p>Tricks are repeating? Missing variety?</p>
        <p>Add new tricks to the database <a href="{{ url_for('expand_database') }}">here</a></p>
    </div>
</div>

<!-- Include noUISlider CSS and JS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
<script src="{{ url_for('static', filename='js/siteswap_x.js') }}"></script>
<script type="module">
    import { fetchTricks, updatePropsSliderRange, updateRelevantTags, setMaxThrowForProp, initMaxThrowBindings, getRandomTrickForDifficulty } from "{{ url_for('static', filename='js/route_helpers.js') }}";

    // Props settings from Flask
    const propsSettings = {{ props_settings|tojson|safe }};
    // Expose globally for macros that initialize sliders and helpers
    window.propsSettings = propsSettings;
    const propsSlider = document.getElementById('props-slider');
    const propsRange = document.getElementById('props-range');
    const propsMinInput = document.getElementById('min-props-input');
    const propsMaxInput = document.getElementById('max-props-input');
    // Max throw elements (move to top so all handlers can use them)
    const maxThrowEnabled = document.getElementById('max-throw-enabled');
    const maxThrowContainer = document.getElementById('max-throw-input-container');
    const maxThrowSlider = document.getElementById('max-throw-slider');
    const maxThrowValue = document.getElementById('max-throw-value');
    const maxThrowInput = document.getElementById('max-throw-input');

    // Get initial prop (first selected). If none selected yet, fall back to the first key in propsSettings.
    const checkedPropInput = document.querySelector('.prop-option-input:checked');
    let selectedProp = checkedPropInput ? checkedPropInput.value : Object.keys(propsSettings)[0];
    let propSettings = propsSettings[selectedProp];
    let minProps = propSettings.min_props;
    let maxProps = propSettings.max_props;


    // Handler for prop change: updates all prop-dependent UI and fetches tricks
    function handlePropChange() {
        const selectedInput = document.querySelector('.prop-option-input:checked');
        if (!selectedInput) return;
        const prop = selectedInput.value;
        const propSettings = propsSettings[prop];
        const minProps = propSettings.min_props;
        const maxProps = propSettings.max_props;

        // Update slider range via helper imported from module
        updatePropsSliderRange(minProps, maxProps);
        propsRange.textContent = `Min: ${minProps}, Max: ${maxProps}`;
        propsMinInput.value = minProps;
        propsMaxInput.value = maxProps;

        // Update relevant tags via imported helper
        updateRelevantTags(propSettings.relevant_tags, '');

        // Use centralized max-throw handler
    // setMaxThrowForProp called for initial prop
    try { setMaxThrowForProp(propSettings); } catch (e) { console.error('setMaxThrowForProp error', e); }

        // Fetch tricks for selected prop and current max throw
        const maxThrowElem = document.getElementById('max-throw-enabled');
        const maxThrow = maxThrowElem && maxThrowElem.checked ? parseInt(document.getElementById('max-throw-input').value) : null;
        // Build request payload with numeric values where available. Use propSettings' min/max props by default.
        const minPropsValue = Number.isFinite(Number(propSettings.min_props)) ? Number(propSettings.min_props) : null;
        const maxPropsValue = Number.isFinite(Number(propSettings.max_props)) ? Number(propSettings.max_props) : null;
        const _minDifficulty = parseInt(document.getElementById('min-difficulty-input').value);
        const _maxDifficulty = parseInt(document.getElementById('max-difficulty-input').value);
        const minDifficultyValue = Number.isFinite(_minDifficulty) ? _minDifficulty : null;
        const maxDifficultyValue = Number.isFinite(_maxDifficulty) ? _maxDifficulty : null;
        const excludedTags = Array.from(document.querySelectorAll('input[name="exclude_tags"]:checked')).map(cb => cb.value);

        // Load all tricks for this prop (no client-side filters yet). Filtering is applied later when generating routes/tooltips.
        fetchTricks({ propType: prop })
            .then(tricks => { 
                window.allTricks = tricks; 
                // fetchTricks resolved
            })
            .catch(error => { console.error('Error fetching tricks:', error); });
    }


    // Attach handler to all prop radio inputs and update .selected class
    document.querySelectorAll('.prop-option-input').forEach(input => {
        input.addEventListener('change', function() {
            // Update .selected class on prop labels
            document.querySelectorAll('.prop-option').forEach(label => {
                const radio = label.querySelector('.prop-option-input');
                if (radio.checked) {
                    label.classList.add('selected');
                } else {
                    label.classList.remove('selected');
                }
            });
            handlePropChange();
        });
    });
    // max-throw handlers are implemented inside the limit_max_throw_macro

    // On page load, select the first prop and trigger change to initialize UI
    document.addEventListener('DOMContentLoaded', function() {
        const firstPropInput = document.querySelector('.prop-option-input');
        if (firstPropInput) {
            // Ensure the radio is checked and UI initialized
            firstPropInput.checked = true;
            const label = firstPropInput.closest('.prop-option');
            if (label) label.classList.add('selected');
            if (typeof handlePropChange === 'function') {
                handlePropChange();
            }
            // Ensure max-throw bindings are active (idempotent)
            try { initMaxThrowBindings(); } catch (e) { console.error('initMaxThrowBindings error', e); }
        }

        // (diagnostic overlay removed) 
    });

    // Difficulty slider and props slider initialization moved into macros
    const difficultySlider = document.getElementById('difficulty-slider');
    const difficultyRange = document.getElementById('difficulty-range');  
    const difficultyMinInput = document.getElementById('min-difficulty-input');
    const difficultyMaxInput = document.getElementById('max-difficulty-input');

    // Store all tricks for the current prop type
    window.allTricks = [];

    // Function to show trick tooltip
    function showTrickTooltip(event, difficulty) {
        if (!Array.isArray(allTricks) || allTricks.length === 0) {
            return;
        }
        const minProps = parseInt(document.getElementById('min-props-input').value);
        const maxProps = parseInt(document.getElementById('max-props-input').value);
        const excludedTags = Array.from(document.querySelectorAll('input[name="exclude_tags"]:checked')).map(cb => cb.value);
        const currentPropInput = document.querySelector('.prop-option-input:checked');
        const currentProp = currentPropInput ? currentPropInput.value : null;

        // Determine maxThrow from checkbox/slider and get a random trick respecting it
        const maxThrowElem = document.getElementById('max-throw-enabled');
        const tooltipMaxThrow = maxThrowElem && maxThrowElem.checked ? parseInt(document.getElementById('max-throw-input').value) : null;
        // Get a random trick for the current difficulty
        let trick = null;
        try {
            trick = getRandomTrickForDifficulty(allTricks, difficulty, minProps, maxProps, excludedTags, tooltipMaxThrow);
        } catch (e) { /* ignore helper errors */ }

        // Diagnostic banner removed

        // Remove any existing tooltip
        const existingTooltip = document.querySelector('.trick-tooltip');
        if (!trick) {
            if (existingTooltip) existingTooltip.remove();
            // No exact-match trick â€” do not show a tooltip
            return;
        }

        if (existingTooltip) existingTooltip.remove();

        const tooltip = document.createElement('div');
        tooltip.className = 'trick-tooltip';
        // Defensive tooltip text: prefer trick.name but fall back to siteswap or a placeholder
        let tooltipText = `${trick.props_count || ''} ${currentProp || ''}: ${trick.name || ''}`;
        if (!tooltipText || tooltipText.trim() === '' || tooltipText.match(/^\s*:\s*$/)) {
            tooltipText = `${trick.props_count || ''} ${currentProp || ''}: ${trick.siteswap || trick.name || '(unknown trick)'}`;
        }
        tooltip.textContent = tooltipText;

        // Determine coordinates (guard against synthetic event objects)
        let x = (event && typeof event.clientX === 'number') ? event.clientX : null;
        let y = (event && typeof event.clientY === 'number') ? event.clientY : null;
        if (x === null || y === null) {
            // Try to derive from target element bounding rect if available
            if (event && event.target && event.target.getBoundingClientRect) {
                const r = event.target.getBoundingClientRect();
                x = Math.round(r.left + r.width / 2);
                y = Math.round(r.top + r.height / 2);
            } else {
                // Fallback to center of viewport
                x = Math.round(window.innerWidth / 2);
                y = Math.round(window.innerHeight / 2);
            }
        }

        // Position the tooltip near the computed point
        tooltip.style.left = (x + 10) + 'px';
        tooltip.style.top = (y + 10) + 'px';

        // Add a bright outline to ensure visibility for debugging
        tooltip.style.outline = '2px solid rgba(255,255,0,0.9)';

        document.body.appendChild(tooltip);

        // Log what element sits under the tooltip point
        try {
            const elAtPoint = document.elementFromPoint(x + 12, y + 12);
            const rect = tooltip.getBoundingClientRect();
            const style = window.getComputedStyle(tooltip);
        } catch (e) { /* ignore elementFromPoint errors */ }

        // Auto-remove after 3 seconds so debug doesn't persist
        setTimeout(() => {
            try { tooltip.remove(); } catch (e) {}
        }, 3000);
    }

    // Expose to global for the difficulty macro which expects window.showTrickTooltip
    try { window.showTrickTooltip = showTrickTooltip; } catch (e) { console.warn('Failed to attach showTrickTooltip to window', e); }

    // Update the difficulty range display (only if slider exists)
    if (difficultySlider && difficultySlider.noUiSlider) {
        difficultySlider.noUiSlider.on('update', function(values) {
            difficultyRange.textContent = `Min: ${values[0]}, Max: ${values[1]}`;
            difficultyMinInput.value = Math.round(values[0]);
            difficultyMaxInput.value = Math.round(values[1]);
        });
    }

    // Difficulty slider hover/tooltip handled inside the difficulty_range_macro

    // Robustly attach tooltip handlers to noUiSlider handles. The slider may be created
    // by the macro after this script runs, so retry and use a MutationObserver.
    function attachDifficultyHandleTooltips() {
        const slider = document.getElementById('difficulty-slider');
        if (!slider) return false;
        const handles = Array.from(slider.querySelectorAll('.noUi-handle'));
        if (!handles || handles.length === 0) return false;

        handles.forEach((handle, index) => {
            if (handle._tooltipHandlerAttached) return;
            const enter = (event) => {
                try {
                    const currentValue = slider.noUiSlider ? parseInt(slider.noUiSlider.get()[index]) : null;
                    if (typeof window.showTrickTooltip === 'function') window.showTrickTooltip(event, currentValue);
                } catch (e) { /* swallow */ }
            };
            const leave = () => {
                try { const t = document.querySelector('.trick-tooltip'); if (t) t.remove(); } catch (e) {}
            };
            handle.addEventListener('mouseenter', enter);
            handle.addEventListener('mouseleave', leave);
            handle._tooltipHandlerAttached = true;
        });

        // Also ensure updates while dragging show tooltip for hovered handle
        if (slider.noUiSlider && typeof slider.noUiSlider.on === 'function') {
            try {
                slider.noUiSlider.on('update', function(values) {
                    try {
                        const handlesNow = Array.from(slider.querySelectorAll('.noUi-handle'));
                        handlesNow.forEach((h, i) => {
                            if (h.matches(':hover')) {
                                const ev = { clientX: h.getBoundingClientRect().left, clientY: h.getBoundingClientRect().top, target: h };
                                if (typeof window.showTrickTooltip === 'function') window.showTrickTooltip(ev, parseInt(values[i]));
                            }
                        });
                    } catch (e) {}
                });
            } catch (e) {}
        }

        return true;
    }

    // Try immediate attach and retry a couple of times; observe mutations on the slider parent
    (function ensureHandlesAttached() {
        let attached = attachDifficultyHandleTooltips();
        if (attached) return;
        // retry timers
        const retries = [200, 800, 1600];
        retries.forEach((ms) => setTimeout(() => { try { attached = attachDifficultyHandleTooltips(); } catch(e){} }, ms));

        // MutationObserver to attach when nodes are added under the slider's parent
        try {
            const parent = document.querySelector('.slider-container') || document.body;
            const mo = new MutationObserver((mutations) => {
                try {
                    if (attachDifficultyHandleTooltips()) {
                        mo.disconnect();
                    }
                } catch (e) {}
            });
            mo.observe(parent, { childList: true, subtree: true });
        } catch (e) { /* ignore */ }
    })();

    // Update the value displayed next to the "Number of Tricks" slider
    const routeLengthSlider = document.getElementById('route-length-slider');
    const routeLengthValue = document.getElementById('route-length-value');
    const routeLengthInput = document.getElementById('route-length-input');
    if (routeLengthSlider && routeLengthValue && routeLengthInput) {
        routeLengthSlider.addEventListener('input', () => {
            routeLengthValue.textContent = routeLengthSlider.value;
            routeLengthInput.value = routeLengthSlider.value;
        });
    }

    // Update the value displayed next to the "Route Duration" slider
    const routeDurationSlider = document.getElementById('route-duration-slider');
    const routeDurationValue = document.getElementById('route-duration-value');
    const routeDurationInput = document.getElementById('route-duration-input');
    if (routeDurationSlider && routeDurationValue && routeDurationInput) {
        routeDurationSlider.addEventListener('input', () => {
            const minutes = parseInt(routeDurationSlider.value);
            routeDurationValue.textContent = minutes;
            routeDurationInput.value = minutes;
        });
    }

    // Max Throw UI is handled by the limit_max_throw_macro

    // Tag interactions are handled by the relevant_tags_macro
</script>
{% endblock %}
