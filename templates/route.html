{% extends "utils/base.html" %}
{% block title %}{{ route.name }}{% endblock %}
{% block content %}
<div class="route-page">
    {% if request.args.get('action') == 'edit' %}
    <div class="route-form">
        <div class="route-header">
            <h1 class="route-title" contenteditable="true">{{ route.name }}</h1>
        </div>

        <div class="form-section">
            <label for="route_duration" class="form-label">Route Duration (minutes)</label>
            <div class="slider-container">
                <div class="slider-wrapper">
                    <input type="range" id="route-duration-slider" min="1" max="30" value="{{ (route.duration_seconds // 60) if route else 10 }}" class="custom-range">
                    <span id="route-duration-value" class="slider-value">{{ (route.duration_seconds // 60) if route else 10 }}</span>
                </div>
                <input type="hidden" id="route-duration-input" name="route_duration" value="{{ (route.duration_seconds // 60) if route else 10 }}">
            </div>
        </div>

        <div class="form-section">
            <label class="form-label">Select Prop</label>
            <div class="prop-group">
                {% for prop in prop_options %}
                    <label class="prop-option {% if route and prop.value == route.prop %}selected{% endif %}" data-prop-type="{{ prop }}">
                        <input type="radio" name="prop" class="prop-option-input" value="{{ prop.value }}" {% if route and prop.value == route.prop %}checked{% endif %}> 
                        <span class="prop-option-name">{{ prop.value }}</span>
                        <div class="prop-icon"></div>
                    </label>
                {% endfor %}
            </div>
        </div>

        <!-- Route Display -->
        <div class="form-section">
            <label class="form-label">Your Route</label>
            <div class="route-container">
                <div class="route-content">
                    <div class="route-sections" id="route-sections">
                        {% include "utils/route_display.html" %}
                    </div>
                </div>
            </div>
            <div class="route-actions">
                <div class="route-buttons">
                    <button type="button" id="view_route" class="primary-button">View Route</button>
                </div>
            </div>
        </div>

        <!-- Add Custom Trick Section -->
        <div class="form-section custom-trick-section">
            <h4 class="subsection-title">Add Custom Trick</h4>
            <div class="custom-trick-form">
                <div class="form-row">
                    <div class="form-group">
                        <label for="custom_trick_name">Trick Name</label>
                        <input type="text" id="custom_trick_name" class="form-input" placeholder="Enter trick name">
                    </div>
                    <div class="form-group">
                        <label for="custom_trick_props">Number of Props</label>
                        <div class="slider-container">
                            <div class="slider-wrapper">
                                <input type="range" id="custom_trick_props" class="custom-range" 
                                    min="{{ MIN_TRICK_PROPS_COUNT }}" 
                                    max="{{ MAX_TRICK_PROPS_COUNT }}" 
                                    value="{{ DEFAULT_MIN_TRICK_PROPS_COUNT }}">
                                <span id="custom_trick_props_value" class="slider-value">{{ DEFAULT_MIN_TRICK_PROPS_COUNT }}</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label for="custom_trick_comment">Comment (Optional)</label>
                    <textarea id="custom_trick_comment" class="form-input" placeholder="Add a comment about the trick"></textarea>
                </div>
                <button type="button" id="add_custom_trick" class="add-trick">Add</button>
            </div>
        </div>

        <div class="form-section">
            <label class="form-label">Exclude Tags</label>
            <div class="tricks-container">
                <div class="tricks-column">
                    <div id="exclude_tags" class="tags-grid">
                        {% for category in tag_categories %}
                            <div class="tag-category">
                                <div class="tag-category-header">
                                    <input type="checkbox" id="category-{{ category.value }}" class="category-checkbox">
                                    <label for="category-{{ category.value }}" class="tag-category-title">
                                        {{ category.value }}
                                    </label>
                                </div>
                                <div class="tag-category-content">
                                    {% for tag in tag_options %}
                                        {% if tag_category_map[tag] == category %}
                                            <div class="checkbox-container">
                                                <input type="checkbox" id="tag-{{ tag.value }}" name="exclude_tags" value="{{ tag.value }}" class="tag-checkbox" data-category="{{ category.value }}">
                                                <label for="tag-{{ tag.value }}">{{ tag.value }}</label>
                                            </div>
                                        {% endif %}
                                    {% endfor %}
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

        <div class="form-section">
            <label class="form-label">Available Tricks</label>
            <div class="tricks-container">
                <div class="tricks-column">
                    <div id="all_tricks" class="tricks-grid">
                        <!-- Tricks will be populated by filterTricks function -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tricks-database">
        <p>Juggler and Open-Source contributor? You can expand the database <a target="_blank" href="https://github.com/ofekraf/jugglefit_website/tree/main/database/tricks">here</a></p>
    </div>
    {% else %}
    <div class="route-layout">
        {% include "utils/route_display.html" %}
    </div>
    {% endif %}
</div>

<div class="route-actions no-print">
    <div class="countdown-timer" id="timer-container">
        <div class="timer-header">
            <span>Timer</span>
            <button class="drag-handle">≡</button>
        </div>
        <div id="countdown">Time remaining: <span id="timer"></span></div>
        <div class="timer-controls">
            <button id="startBtn" class="timer-btn">Start</button>
            <button id="stopBtn" class="timer-btn" disabled>Stop</button>
            <button id="resetBtn" class="timer-btn">Reset</button>
        </div>
    </div>
    <div class="route-buttons">
        <button class="primary-button" onclick="shareRoute()">Share</button>
        {% if not request.args.get('action') == 'edit' %}
        <a href="{{ url_for('route', route=route.serialize()|urlencode, action='edit') }}" class="primary-button">Edit</a>
        {% endif %}
        <button class="primary-button print-button" onclick="printRoute()">Print</button>
    </div>
</div>

<!-- Print-only container -->
<div id="print-container" class="print-only">
    <div class="print-header">
        <h1 id="print-route-name"></h1>
    </div>
    <div id="print-route-content"></div>
</div>

<!-- Toast Notification -->
<div id="toast" class="toast-notification"></div>

<!-- Include noUISlider CSS and JS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="{{ url_for('static', filename='js/tricks_utils.js') }}"></script>
<script src="{{ url_for('static', filename='js/general.js') }}"></script>

<!-- Pass Flask data to JavaScript -->
<script>
    // Constants from trick.py
    const MIN_TRICK_PROPS_COUNT = parseInt('{{ MIN_TRICK_PROPS_COUNT }}');
    const MAX_TRICK_PROPS_COUNT = parseInt('{{ MAX_TRICK_PROPS_COUNT }}');
    const MIN_TRICK_DIFFICULTY = parseInt('{{ MIN_TRICK_DIFFICULTY }}');
    const MAX_TRICK_DIFFICULTY = parseInt('{{ MAX_TRICK_DIFFICULTY }}');
    const DEFAULT_MIN_TRICK_PROPS_COUNT = parseInt('{{ DEFAULT_MIN_TRICK_PROPS_COUNT }}');
    const DEFAULT_MAX_TRICK_PROPS_COUNT = parseInt('{{ DEFAULT_MAX_TRICK_PROPS_COUNT }}');
    const DEFAULT_MIN_TRICK_DIFFICULTY = parseInt('{{ DEFAULT_MIN_TRICK_DIFFICULTY }}');
    const DEFAULT_MAX_TRICK_DIFFICULTY = parseInt('{{ DEFAULT_MAX_TRICK_DIFFICULTY }}');
    const IS_EDIT_MODE = {{ 'true' if request.args.get('action') == 'edit' else 'false' }};

    // Toast notification function
    function showToast(message, focusElementId = null) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.classList.add('show');
        
        if (focusElementId) {
            const element = document.getElementById(focusElementId);
            if (element) {
                element.focus();
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        
        setTimeout(() => {
            toast.classList.remove('show');
        }, 3000);
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Initialize countdown timer
        let timeLeft = parseInt('{{ route.duration_seconds }}') || 600;
        let timerInterval = null;
        let isRunning = false;
        const originalTime = timeLeft;

        // Share Route functionality
        function shareRoute() {
            navigator.clipboard.writeText(window.location.href).then(() => {
                showToast('Route URL copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy URL: ', err);
                showToast('Failed to copy URL. Please try again.');
            });
        }

        // Add checkboxes to all tricks
        const trickContents = document.querySelectorAll('.trick-content');
        trickContents.forEach(content => {
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'trick-checkbox no-print';
            
            checkbox.addEventListener('change', function() {
                const trickNumber = content.querySelector('.trick-number');
                const trickName = content.querySelector('.trick-name');
                const trickComment = content.querySelector('.trick-comment');
                
                if (this.checked) {
                    if (trickNumber) trickNumber.style.textDecoration = 'line-through';
                    if (trickName) trickName.style.textDecoration = 'line-through';
                    if (trickComment) trickComment.style.textDecoration = 'line-through';
                } else {
                    if (trickNumber) trickNumber.style.textDecoration = 'none';
                    if (trickName) trickName.style.textDecoration = 'none';
                    if (trickComment) trickComment.style.textDecoration = 'none';
                }
            });
            
            content.insertBefore(checkbox, content.firstChild);
        });

        function updateTimer() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            document.getElementById('timer').textContent = 
                minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
            
            if (timeLeft > 0) {
                timeLeft--;
            } else {
                stopTimer();
                document.getElementById('countdown').textContent = "Time's up!";
            }
        }

        function startTimer() {
            if (!isRunning) {
                isRunning = true;
                timerInterval = setInterval(updateTimer, 1000);
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
            }
        }

        function stopTimer() {
            if (isRunning) {
                isRunning = false;
                clearInterval(timerInterval);
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }

        function resetTimer() {
            stopTimer();
            timeLeft = originalTime;
            document.getElementById('countdown').innerHTML = 'Time remaining: <span id="timer"></span>';
            updateTimer();
        }

        // Add event listeners for buttons
        document.getElementById('startBtn').addEventListener('click', startTimer);
        document.getElementById('stopBtn').addEventListener('click', stopTimer);
        document.getElementById('resetBtn').addEventListener('click', resetTimer);

        // Initialize timer display immediately
        updateTimer();

        // Timer drag functionality
        const timer = document.querySelector('.countdown-timer');
        const timerHeader = timer.querySelector('.timer-header');
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;

        function dragStart(e) {
            if (e.type === "touchstart") {
                initialX = e.touches[0].clientX - xOffset;
                initialY = e.touches[0].clientY - yOffset;
            } else {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }

            if (e.target === timer || e.target === timerHeader || e.target.closest('.timer-header')) {
                isDragging = true;
            }
        }

        function dragEnd(e) {
            initialX = currentX;
            initialY = currentY;
            isDragging = false;
        }

        function drag(e) {
            if (isDragging) {
                e.preventDefault();

                if (e.type === "touchmove") {
                    currentX = e.touches[0].clientX - initialX;
                    currentY = e.touches[0].clientY - initialY;
                } else {
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                }

                xOffset = currentX;
                yOffset = currentY;

                setTranslate(currentX, currentY, timer);
            }
        }

        function setTranslate(xPos, yPos, el) {
            el.style.transform = `translate(${xPos}px, ${yPos}px)`;
        }

        timerHeader.addEventListener("touchstart", dragStart, false);
        timerHeader.addEventListener("touchend", dragEnd, false);
        timerHeader.addEventListener("touchmove", drag, false);

        timerHeader.addEventListener("mousedown", dragStart, false);
        timerHeader.addEventListener("mouseup", dragEnd, false);
        timerHeader.addEventListener("mousemove", drag, false);

        // Print Route functionality
        function printRoute() {
            const existingQRCodes = document.querySelectorAll('.qr-code');
            existingQRCodes.forEach(qr => {
                qr.innerHTML = '';
                qr.remove();
            });

            let qrContainer = document.createElement('div');
            qrContainer.className = 'qr-code print-only';
            
            const routeContent = document.querySelector('.route-content');
            routeContent.appendChild(qrContainer);

            new QRCode(qrContainer, {
                text: window.location.href,
                width: 280,
                height: 280,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });

            const cleanup = () => {
                qrContainer.innerHTML = '';
                qrContainer.remove();
                window.removeEventListener('afterprint', cleanup);
            };
            window.addEventListener('afterprint', cleanup);

            setTimeout(() => {
                window.print();
            }, 100);
        }

        {% if request.args.get('action') == 'edit' %}
        // Initialize route from current route data
        let currentRoute = {
            name: '{{ route.name if route else "" }}',
            prop: '{{ route.prop if route else "" }}',
            tricks: {{ route.tricks|tojson|safe if route else '[]' }},
            duration_seconds: {{ route.duration_seconds if route else 600 }}
        };

        // Store all tricks for the current prop type
        let allTricks = [];

        // Function to fetch tricks for a prop type
        async function fetchTricksForProp(propType) {
            try {
                const response = await fetch('/api/fetch_tricks', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        prop_type: propType,
                        min_props: DEFAULT_MIN_TRICK_PROPS_COUNT,
                        max_props: DEFAULT_MAX_TRICK_PROPS_COUNT,
                        min_difficulty: DEFAULT_MIN_TRICK_DIFFICULTY,
                        max_difficulty: DEFAULT_MAX_TRICK_DIFFICULTY
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch tricks');
                }
                
                const tricks = await response.json();
                allTricks = tricks;
                updateSearchTricks();
            } catch (error) {
                console.error('Error fetching tricks:', error);
                showToast('Error loading tricks. Please try again.');
            }
        }

        // Function to initialize sliders
        function initializeSliders() {
            // Initialize route duration slider
            const routeDurationSlider = document.getElementById('route-duration-slider');
            const routeDurationValue = document.getElementById('route-duration-value');
            const routeDurationInput = document.getElementById('route-duration-input');
            
            if (routeDurationSlider && routeDurationValue && routeDurationInput) {
                routeDurationSlider.addEventListener('input', () => {
                    const minutes = parseInt(routeDurationSlider.value);
                    routeDurationValue.textContent = minutes;
                    routeDurationInput.value = minutes;
                    currentRoute.duration_seconds = minutes * 60;
                });
            }

            // Initialize custom trick props slider
            const customTrickPropsSlider = document.getElementById('custom_trick_props');
            const customTrickPropsValue = document.getElementById('custom_trick_props_value');
            
            if (customTrickPropsSlider && customTrickPropsValue) {
                customTrickPropsSlider.addEventListener('input', () => {
                    const value = parseInt(customTrickPropsSlider.value);
                    customTrickPropsValue.textContent = value;
                });
            }
        }

        // Function to update search tricks
        function updateSearchTricks() {
            const minPropsInput = document.getElementById('min-props-input');
            const maxPropsInput = document.getElementById('max-props-input');
            const minDifficultyInput = document.getElementById('min-difficulty-input');
            const maxDifficultyInput = document.getElementById('max-difficulty-input');

            // If the filter inputs don't exist yet, use default values
            const minProps = minPropsInput ? parseInt(minPropsInput.value) : DEFAULT_MIN_TRICK_PROPS_COUNT;
            const maxProps = maxPropsInput ? parseInt(maxPropsInput.value) : DEFAULT_MAX_TRICK_PROPS_COUNT;
            const minDifficulty = minDifficultyInput ? parseInt(minDifficultyInput.value) : DEFAULT_MIN_TRICK_DIFFICULTY;
            const maxDifficulty = maxDifficultyInput ? parseInt(maxDifficultyInput.value) : DEFAULT_MAX_TRICK_DIFFICULTY;
            
            const excludedTags = Array.from(document.querySelectorAll('input[name="exclude_tags"]:checked')).map(cb => cb.value);

            // Filter tricks based on criteria
            const filteredTricks = filterTricks(allTricks, minProps, maxProps, minDifficulty, maxDifficulty, excludedTags);

            // Group filtered tricks by props count
            const groupedTricks = groupTricksByPropsCount(filteredTricks);

            // Update the tricks display
            const tricksGrid = document.getElementById('all_tricks');
            if (!tricksGrid) return;
            
            tricksGrid.innerHTML = '';

            // Display tricks grouped by props count
            Object.keys(groupedTricks).sort((a, b) => parseInt(a) - parseInt(b)).forEach(count => {
                const group = document.createElement('div');
                group.className = 'props-group';
                
                const header = document.createElement('h3');
                header.className = 'props-count-header';
                header.textContent = `${count} Props`;
                group.appendChild(header);
                
                const tricksList = document.createElement('div');
                tricksList.className = 'tricks-list';
                
                let trickCounter = 1;
                groupedTricks[count].sort((a, b) => a.name.localeCompare(b.name)).forEach(trick => {
                    const trickItem = document.createElement('div');
                    trickItem.className = 'trick-item';
                    
                    const trickContent = document.createElement('div');
                    trickContent.className = 'trick-content';
                    
                    const trickMain = document.createElement('div');
                    trickMain.className = 'trick-main';
                    
                    const number = document.createElement('span');
                    number.className = 'trick-number';
                    number.textContent = `${trickCounter}.`;
                    trickMain.appendChild(number);
                    
                    const name = document.createElement('span');
                    name.className = 'trick-name';
                    name.textContent = trick.name;
                    name.contentEditable = true;
                    name.addEventListener('blur', function() {
                        const newName = this.textContent.trim();
                        if (newName) {
                            trick.name = newName;
                            frame.setAttribute('data-trick-name', newName);
                        } else {
                            this.textContent = trick.name;
                        }
                    });
                    trickMain.appendChild(name);
                    
                    if (trick.comment) {
                        const comment = document.createElement('span');
                        comment.className = 'trick-comment';
                        comment.textContent = ` [${trick.comment}]`;
                        comment.contentEditable = true;
                        comment.addEventListener('blur', function() {
                            const newComment = this.textContent.replace(/[\[\]]/g, '').trim();
                            trick.comment = newComment;
                            this.textContent = newComment ? ` [${newComment}]` : '';
                        });
                        trickMain.appendChild(comment);
                    }
                    
                    trickContent.appendChild(trickMain);
                    
                    const addButton = document.createElement('button');
                    addButton.className = 'add-trick';
                    addButton.textContent = 'Add';
                    addButton.onclick = () => addTrickToRoute(trick);
                    trickItem.appendChild(addButton);
                    
                    tricksList.appendChild(trickItem);
                });
                
                group.appendChild(tricksList);
                tricksGrid.appendChild(group);
            });
        }

        // Initialize route from current route data
        if (currentRoute) {
            // Set route name
            const routeTitle = document.querySelector('.route-title');
            if (routeTitle) {
                routeTitle.textContent = currentRoute.name;
                routeTitle.contentEditable = true;
                routeTitle.addEventListener('blur', function() {
                    const newName = this.textContent.trim();
                    if (newName) {
                        currentRoute.name = newName;
                    } else {
                        this.textContent = currentRoute.name;
                    }
                });
            }

            // Set duration
            const durationMinutes = Math.floor(currentRoute.duration_seconds / 60);
            document.getElementById('route-duration-slider').value = durationMinutes;
            document.getElementById('route-duration-value').textContent = durationMinutes;
            
            // Set prop type and fetch initial tricks
            const propInput = document.querySelector(`input[value="${currentRoute.prop}"]`);
            if (propInput) {
                propInput.checked = true;
                const propOption = propInput.closest('.prop-option');
                if (propOption) {
                    propOption.classList.add('selected');
                }
                // Fetch tricks for the initial prop type
                fetchTricksForProp(currentRoute.prop);
            }
            
            updateRouteDisplay();
        }

        // Function to initialize prop selection
        function initializePropSelection() {
            const propOptions = document.querySelectorAll('.prop-option');
            const propInputs = document.querySelectorAll('.prop-option-input');

            function updateSelectedState() {
                propOptions.forEach(option => {
                    const input = option.querySelector('.prop-option-input');
                    if (input.checked) {
                        option.classList.add('selected');
                        if (currentRoute.prop !== input.value) {
                            currentRoute.tricks = [];
                            currentRoute.prop = input.value;
                            // Fetch tricks when prop type changes
                            fetchTricksForProp(input.value);
                        }
                        updateRouteDisplay();
                    } else {
                        option.classList.remove('selected');
                    }
                });
            }

            updateSelectedState();

            propOptions.forEach(option => {
                option.addEventListener('click', function() {
                    propInputs.forEach(input => input.checked = false);
                    const input = this.querySelector('.prop-option-input');
                    input.checked = true;
                    updateSelectedState();
                });
            });

            propInputs.forEach(input => {
                input.addEventListener('change', updateSelectedState);
            });
        }

        // Function to initialize other event listeners
        function initializeEventListeners() {
            document.querySelectorAll('input[name="exclude_tags"]').forEach(checkbox => {
                checkbox.addEventListener('change', updateSearchTricks);
            });
        }

        // Function to update route display
        function updateRouteDisplay() {
            const routeSections = document.getElementById('route-sections');
            routeSections.innerHTML = '';

            let currentPropsCount = null;
            let currentSection = null;
            let trickCounter = 1;

            currentRoute.tricks.forEach((trick, index) => {
                if (currentPropsCount !== trick.props_count || 
                    (index > 0 && currentRoute.tricks[index - 1].props_count !== trick.props_count)) {
                    if (currentSection) {
                        currentSection.querySelector('.trick-container').appendChild(document.createElement('div'));
                    }

                    const section = document.createElement('div');
                    section.className = 'prop-section';
                    section.setAttribute('data-props-count', trick.props_count);
                    
                    const colorBar = document.createElement('div');
                    colorBar.className = 'prop-color-bar';
                    colorBar.setAttribute('data-props', trick.props_count);
                    colorBar.setAttribute('data-prop-type', currentRoute.prop);
                    colorBar.setAttribute('draggable', 'true');
                    
                    const propCount = document.createElement('div');
                    propCount.className = 'prop-count';
                    
                    const propCountText = document.createElement('div');
                    propCountText.className = 'prop-count-text';
                    propCountText.textContent = trick.props_count;
                    
                    propCount.appendChild(propCountText);
                    colorBar.appendChild(propCount);
                    section.appendChild(colorBar);
                    
                    const trickContainer = document.createElement('div');
                    trickContainer.className = 'trick-container';
                    trickContainer.setAttribute('data-props-count', trick.props_count);
                    
                    section.appendChild(trickContainer);
                    routeSections.appendChild(section);
                    
                    colorBar.addEventListener('dragstart', handleSectionDragStart);
                    colorBar.addEventListener('dragover', handleSectionDragOver);
                    colorBar.addEventListener('drop', handleSectionDrop);
                    colorBar.addEventListener('dragend', handleSectionDragEnd);
                    
                    currentSection = section;
                    currentPropsCount = trick.props_count;
                }

                const frame = document.createElement('div');
                frame.className = 'prop-details-frame';
                frame.setAttribute('draggable', 'true');
                frame.setAttribute('data-trick-name', trick.name);
                
                const trickContent = document.createElement('div');
                trickContent.className = 'trick-content';
                
                const trickMain = document.createElement('div');
                trickMain.className = 'trick-main';
                
                const number = document.createElement('span');
                number.className = 'trick-number';
                number.textContent = `${trickCounter}.`;
                trickMain.appendChild(number);
                
                const name = document.createElement('span');
                name.className = 'trick-name';
                name.textContent = trick.name;
                name.contentEditable = true;
                name.addEventListener('blur', function() {
                    const newName = this.textContent.trim();
                    if (newName) {
                        trick.name = newName;
                        frame.setAttribute('data-trick-name', newName);
                    } else {
                        this.textContent = trick.name;
                    }
                });
                trickMain.appendChild(name);
                
                if (trick.comment) {
                    const comment = document.createElement('span');
                    comment.className = 'trick-comment';
                    comment.textContent = ` [${trick.comment}]`;
                    comment.contentEditable = true;
                    comment.addEventListener('blur', function() {
                        const newComment = this.textContent.replace(/[\[\]]/g, '').trim();
                        trick.comment = newComment;
                        this.textContent = newComment ? ` [${newComment}]` : '';
                    });
                    trickMain.appendChild(comment);
                }
                
                trickContent.appendChild(trickMain);
                
                const removeButton = document.createElement('button');
                removeButton.className = 'remove-trick';
                removeButton.textContent = '×';
                removeButton.onclick = () => removeTrick(trick);
                trickContent.appendChild(removeButton);
                
                frame.appendChild(trickContent);
                
                frame.addEventListener('dragstart', handleDragStart);
                frame.addEventListener('dragover', handleDragOver);
                frame.addEventListener('drop', handleDrop);
                frame.addEventListener('dragend', handleDragEnd);
                
                currentSection.querySelector('.trick-container').appendChild(frame);
                trickCounter++;
            });
        }

        // Drag and drop functionality
        let draggedItem = null;
        let draggedSection = null;

        function handleDragStart(e) {
            draggedItem = e.target;
            e.target.classList.add('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
            const frame = e.target.closest('.prop-details-frame');
            if (!frame || frame === draggedItem) return;
            
            const container = frame.parentElement;
            const rect = frame.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            
            if (e.clientY < midY) {
                container.insertBefore(draggedItem, frame);
            } else {
                container.insertBefore(draggedItem, frame.nextSibling);
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('dragging');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedItem = null;
            
            const frames = document.querySelectorAll('.prop-details-frame');
            const newTricks = [];
            let currentPropsCount = null;
            let currentSection = null;
            
            frames.forEach(frame => {
                const name = frame.getAttribute('data-trick-name');
                const trick = currentRoute.tricks.find(t => t.name === name);
                if (trick) {
                    if (currentPropsCount !== trick.props_count || currentSection !== frame.closest('.prop-section')) {
                        currentPropsCount = trick.props_count;
                        currentSection = frame.closest('.prop-section');
                    }
                    newTricks.push(trick);
                }
            });
            
            currentRoute.tricks = newTricks;
            updateRouteDisplay();
        }

        function handleSectionDragStart(e) {
            draggedSection = e.target.closest('.prop-section');
            draggedSection.classList.add('dragging');
            draggedSection.style.opacity = '0.5';
        }

        function handleSectionDragOver(e) {
            e.preventDefault();
            const section = e.target.closest('.prop-section');
            if (!section || section === draggedSection) return;
            
            const container = section.parentElement;
            const rect = section.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            
            if (e.clientY < midY) {
                container.insertBefore(draggedSection, section);
            } else {
                container.insertBefore(draggedSection, section.nextSibling);
            }
        }

        function handleSectionDrop(e) {
            e.preventDefault();
            e.target.classList.remove('dragging');
        }

        function handleSectionDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedSection.style.opacity = '1';
            draggedSection = null;
            
            const sections = document.querySelectorAll('.prop-section');
            const newTricks = [];
            sections.forEach(section => {
                const frames = section.querySelectorAll('.prop-details-frame');
                frames.forEach(frame => {
                    const name = frame.getAttribute('data-trick-name');
                    const trick = currentRoute.tricks.find(t => t.name === name);
                    if (trick) newTricks.push(trick);
                });
            });
            currentRoute.tricks = newTricks;
            
            updateRouteDisplay();
            updateSearchTricks();
        }

        function addTrickToRoute(trick) {
            const isDuplicate = currentRoute.tricks.some(t => 
                t.name === trick.name && t.props_count === trick.props_count
            );
            
            if (isDuplicate) {
                showToast('This trick is already in your route.');
                return;
            }
            
            currentRoute.tricks.push(trick);
            updateRouteDisplay();
        }

        function removeTrick(trick) {
            currentRoute.tricks = currentRoute.tricks.filter(t => t.name !== trick.name);
            updateRouteDisplay();
        }

        // Initialize sliders and event listeners
        initializeSliders();
        initializePropSelection();
        initializeEventListeners();

        // Add Custom Trick functionality
        document.getElementById('add_custom_trick').addEventListener('click', function() {
            const name = document.getElementById('custom_trick_name').value.trim();
            const propsCount = parseInt(document.getElementById('custom_trick_props').value);
            const comment = document.getElementById('custom_trick_comment').value.trim();

            if (!name) {
                showToast('Please enter a trick name', 'custom_trick_name');
                return;
            }

            const customTrick = {
                name: name,
                props_count: propsCount,
                difficulty: 30,
                tags: [],
                comment: comment || null
            };

            addTrickToRoute(customTrick);

            document.getElementById('custom_trick_name').value = '';
            document.getElementById('custom_trick_props').value = '{{ DEFAULT_MIN_TRICK_PROPS_COUNT }}';
            document.getElementById('custom_trick_props_value').textContent = '{{ DEFAULT_MIN_TRICK_PROPS_COUNT }}';
            document.getElementById('custom_trick_comment').value = '';
        });

        // View route functionality
        document.getElementById('view_route').addEventListener('click', async function() {
            if (!currentRoute.name) {
                showToast('Please enter a route name before viewing.', 'route_name');
                return;
            }
            if (!currentRoute.prop) {
                showToast('Please select a prop type before viewing.', 'prop-slider');
                return;
            }
            if (currentRoute.tricks.length === 0) {
                showToast('Please add some tricks to your route before viewing.', 'all_tricks');
                return;
            }

            try {
                const response = await fetch('/api/serialize_route', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(currentRoute)
                });
                const serialized = await response.text();
                
                window.location.href = `/route?route=${encodeURIComponent(serialized)}`;
            } catch (error) {
                console.error('Error preparing route for viewing:', error);
                showToast('Error preparing route for viewing. Please try again.');
            }
        });

        // Tag category functionality
        document.querySelectorAll('.tag-category-title').forEach(title => {
            title.addEventListener('click', function(e) {
                if (e.target.type === 'checkbox') return;
                
                const header = this.closest('.tag-category-header');
                const content = header.nextElementSibling;
                content.classList.toggle('expanded');
            });
        });

        // Category checkbox functionality
        document.querySelectorAll('.category-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function(e) {
                e.stopPropagation();
                
                const category = this.id.replace('category-', '');
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox[data-category="${category}"]`);
                relatedCheckboxes.forEach(cb => {
                    cb.checked = this.checked;
                });
                updateSearchTricks();
            });
        });

        // Update category checkbox when individual tags change
        document.querySelectorAll('.tag-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const category = this.dataset.category;
                const categoryCheckbox = document.getElementById(`category-${category}`);
                const relatedCheckboxes = document.querySelectorAll(`.tag-checkbox[data-category="${category}"]`);
                const allChecked = Array.from(relatedCheckboxes).every(cb => cb.checked);
                const someChecked = Array.from(relatedCheckboxes).some(cb => cb.checked);
                
                categoryCheckbox.checked = allChecked;
                categoryCheckbox.indeterminate = someChecked && !allChecked;
                
                updateSearchTricks();
            });
        });
        {% endif %}
    });
</script>
{% endblock %} 