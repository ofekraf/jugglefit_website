{% extends "macros/base.html" %}
{% block title %}Route - JuggleFit{% endblock %}
{% block content %}
<div class="route-page created-route-page">
    <div class="route-header">
        <h1 id="route-title" class="route-title">Route</h1>
    </div>
    
    <div class="route-layout">
        <div id="route-sections" class="route-sections">
            <!-- Route content will be populated by JavaScript -->
        </div>
    </div>
</div>

<div class="route-actions no-print">
    <div class="countdown-timer" id="timer-container">
        <div class="timer-header">
            <span>Timer</span>
            <button class="drag-handle">â‰¡</button>
        </div>
        <div id="countdown"><span id="timer"></span></div>
        <div class="timer-controls">
            <button id="startBtn" class="timer-btn">Start</button>
            <button id="stopBtn" class="timer-btn" disabled>Stop</button>
            <button id="resetBtn" class="timer-btn">Reset</button>
        </div>
    </div>
    <div class="route-buttons">
        <button class="primary-button" onclick="shareRoute()">Share</button>
        <a id="live-event-link" href="#" class="primary-button live-event-button">Live Event</a>
        <a id="edit-route-link" href="#" class="primary-button">Edit</a>
        <button class="primary-button print-button" onclick="printRoute()">Print with QR</button>
        <button class="primary-button print-button" onclick="printRouteWithoutQR()">Print without QR</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<script src="{{ url_for('static', filename='js/general.js') }}"></script>
<script src="{{ url_for('static', filename='js/siteswap_x.js') }}"></script>

<script type="module">
    // Import route loading functions
    const { loadRoute, initRouteLoading } = await import("{{ url_for('static', filename='js/route_helpers.js') }}");
    
    // Make functions available globally
    window.loadRoute = loadRoute;
    window.initRouteLoading = initRouteLoading;
    
    // Initialize route loading immediately 
    initRouteLoading(updateUIWithRoute);
    
    // Update UI elements after route loads
    // Removed all DOMContentLoaded logic to prevent post-load interference
    
    function updateUIWithRoute() {
        if (!window.currentRoute) return;
        
        const titleElement = document.getElementById('route-title');
        if (titleElement) {
            titleElement.textContent = window.currentRoute.name || 'Untitled Route';
        }
        
        // Update timer with correct duration
        originalDuration = window.currentRoute.duration_seconds || 600;
        if (typeof resetTimer === 'function') {
            resetTimer();
        }
        
        // Update action links with current route parameter
        const urlParams = new URLSearchParams(window.location.search);
        const routeParam = urlParams.get('route');
        if (routeParam) {
            const encodedRoute = encodeURIComponent(routeParam);
            const liveEventLink = document.getElementById('live-event-link');
            const editRouteLink = document.getElementById('edit-route-link');
            
            if (liveEventLink) {
                liveEventLink.href = `/live_event?route=${encodedRoute}`;
            }
            if (editRouteLink) {
                const siteswapToggle = document.getElementById('toggle-siteswap-x-checkbox');
                const siteswapXEnabled = siteswapToggle && siteswapToggle.checked;
                let editUrl = `/build_route?route=${encodedRoute}`;
                if (siteswapXEnabled) {
                    editUrl += '&siteswapx=1';
                }
                editRouteLink.href = editUrl;
            }
        }
    }
</script>

<script>
    // Initialize countdown timer
    let finalTime = null;
    let timerInterval = null;
    let isRunning = false;
    let originalDuration = 600; // Default, will be updated when route loads

    // Helper function to get shortened URL
    async function getShortenedUrl(longUrl) {
        try {
            const response = await fetch('/api/shorten_url', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ long_url: longUrl })
            });
            const data = await response.json();
            return data.short_url || null;
        } catch (error) {
            console.error('URL Shortening Error:', error);
            return null;
        }
    }

    // Share Route functionality
    async function shareRoute() {
        const shareBtn = document.querySelector('button[onclick="shareRoute()"]');
        const originalText = shareBtn.textContent;
        shareBtn.textContent = 'Shortening...';
        shareBtn.disabled = true;

        const longUrl = window.location.href;
        
        try {
            const shortUrl = await getShortenedUrl(longUrl);
            const urlToShare = shortUrl || longUrl;
            
            await navigator.clipboard.writeText(urlToShare);
            if (shortUrl) {
                showToast('URL copied to clipboard!');
            } else {
                showToast('Long URL copied (Shortener unavailable)');
            }
        } catch (err) {
            console.error('Failed to copy URL: ', err);
            // Fallback to long URL if anything goes wrong
            try {
                await navigator.clipboard.writeText(longUrl);
                showToast('Long URL copied (Shortener failed)');
            } catch (clipboardErr) {
                showToast('Failed to copy URL. Please try again.');
            }
        } finally {
            shareBtn.textContent = originalText;
            shareBtn.disabled = false;
        }
    }

    // Toast notification function
    function showToast(message) {
        const toast = document.createElement('div');
        toast.className = 'toast-notification';
        toast.textContent = message;
        document.body.appendChild(toast);
        
        // Show the toast
        setTimeout(() => {
            toast.classList.add('show');
        }, 100);
        
        // Hide and remove the toast after 3 seconds
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 3000);
    }

    function updateTimer() {
        if (!finalTime) return;
        
        const now = new Date().getTime();
        const timeLeft = Math.max(0, Math.floor((finalTime - now) / 1000));
        
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        document.getElementById('timer').textContent = 
            minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
        
        if (timeLeft <= 0) {
            stopTimer();
            document.getElementById('countdown').textContent = "Time's up!";
        }
    }

    function startTimer() {
        if (!isRunning) {
            isRunning = true;
            // Only set finalTime if it's not already set (i.e., not resuming)
            if (!finalTime) {
                finalTime = new Date().getTime() + (originalDuration * 1000);
            }
            timerInterval = setInterval(updateTimer, 100); // Update more frequently for smoother display
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            updateTimer(); // Update immediately
        }
    }

    function stopTimer() {
        if (isRunning) {
            isRunning = false;
            clearInterval(timerInterval);
            // Don't reset finalTime when stopping, so we can resume from the same point
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }
    }

    function resetTimer() {
        stopTimer();
        finalTime = null; // Only reset finalTime when explicitly resetting
        document.getElementById('countdown').innerHTML = 'Time remaining: <span id="timer"></span>';
        const minutes = Math.floor(originalDuration / 60);
        const seconds = originalDuration % 60;
        document.getElementById('timer').textContent = 
            minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
    }

    // Add event listeners for buttons
    document.getElementById('startBtn').addEventListener('click', startTimer);
    document.getElementById('stopBtn').addEventListener('click', stopTimer);
    document.getElementById('resetBtn').addEventListener('click', resetTimer);

    // Initialize timer display immediately
    resetTimer();

    // Timer drag functionality
    const timer = document.querySelector('.countdown-timer');
    const timerHeader = timer.querySelector('.timer-header');
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;

    function dragStart(e) {
        if (e.type === "touchstart") {
            initialX = e.touches[0].clientX - xOffset;
            initialY = e.touches[0].clientY - yOffset;
        } else {
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;
        }

        if (e.target === timer || e.target === timerHeader || e.target.closest('.timer-header')) {
            isDragging = true;
        }
    }

    function dragEnd(e) {
        initialX = currentX;
        initialY = currentY;
        isDragging = false;
    }

    function drag(e) {
        if (isDragging) {
            e.preventDefault();

            if (e.type === "touchmove") {
                currentX = e.touches[0].clientX - initialX;
                currentY = e.touches[0].clientY - initialY;
            } else {
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
            }

            xOffset = currentX;
            yOffset = currentY;

            setTranslate(currentX, currentY, timer);
        }
    }

    function setTranslate(xPos, yPos, el) {
        el.style.transform = `translate(${xPos}px, ${yPos}px)`;
    }

    timerHeader.addEventListener("touchstart", dragStart, false);
    timerHeader.addEventListener("touchend", dragEnd, false);
    timerHeader.addEventListener("touchmove", drag, false);

    timerHeader.addEventListener("mousedown", dragStart, false);
    timerHeader.addEventListener("mouseup", dragEnd, false);
    timerHeader.addEventListener("mousemove", drag, false);

    // Print Route functionality
    async function printRoute() {
        const printBtn = document.querySelector('button[onclick="printRoute()"]');
        const originalText = printBtn.textContent;
        printBtn.textContent = 'Generating QR...';
        printBtn.disabled = true;

        // Remove any existing QR code containers and their contents
        const existingQRCodes = document.querySelectorAll('.qr-code');
        existingQRCodes.forEach(qr => {
            qr.innerHTML = '';
            qr.remove();
        });

        // Create a temporary container for the QR code
        let qrContainer = document.createElement('div');
        qrContainer.className = 'qr-code print-only';
        
        // Append to the route content instead of body
        const routeContent = document.querySelector('.route-sections');
        routeContent.appendChild(qrContainer);

        // Get the current long URL
        const longUrl = window.location.href;

        try {
            const shortUrl = await getShortenedUrl(longUrl);
            const urlToUse = shortUrl || longUrl;

            // Generate QR code for the short URL
            new QRCode(qrContainer, {
                text: urlToUse,
                width: 280,
                height: 280,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
            if (!shortUrl) {
                showToast('Heavy QR generated due to server error');
            }
        } catch (error) {
            console.error('QR Generation Error:', error);
            // Fallback: generate QR for the long URL if API fails
            new QRCode(qrContainer, {
                text: longUrl,
                width: 280,
                height: 280,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
            showToast('Heavy QR generated due to server error');
        } finally {
            printBtn.textContent = originalText;
            printBtn.disabled = false;
        }

        // Add event listener for afterprint
        const cleanup = () => {
            qrContainer.innerHTML = '';
            qrContainer.remove();
            window.removeEventListener('afterprint', cleanup);
        };
        window.addEventListener('afterprint', cleanup);

        // Wait for QR code to be generated before printing
        setTimeout(() => {
            window.print();
        }, 500); // Increased timeout to ensure QR renders
    }

    function printRouteWithoutQR() {
        // Remove any existing QR code
        const existingQRCodes = document.querySelectorAll('.qr-code');
        existingQRCodes.forEach(qr => {
            qr.innerHTML = '';
            qr.remove();
        });

        // Add event listener for afterprint
        const cleanup = () => {
            window.removeEventListener('afterprint', cleanup);
        };
        window.addEventListener('afterprint', cleanup);

        // Wait a moment for cleanup, then print
        setTimeout(() => {
            window.print();
        }, 100);
    }
</script>
{% endblock %}